{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "ChronoConfigCollectionsConfig": {
      "properties": {
        "group_teams": {
          "description": "Ordered map of prometheus group regexes to chronosphere team slug. This is used to\ndetermine which team will own the collection created for each prometheus group..",
          "items": {
            "$ref": "#/definitions/CollectionsConfigGroupTeam"
          },
          "type": "array"
        },
        "notification_policy_team_slug": {
          "description": "The team that will own the generated notification policy",
          "type": "string"
        }
      },
      "title": "Configuration for when ContainerType == COLLECTIONS or DEFAULT is collections",
      "type": "object"
    },
    "ChronoConfigSeverityMapping": {
      "properties": {
        "chronosphere_severity": {
          "$ref": "#/definitions/SeverityMappingSeverity"
        },
        "severity": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "CollectionsConfigGroupTeam": {
      "properties": {
        "group_regex": {
          "type": "string"
        },
        "team_slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateDashboardBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the Dashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dashboard does not already exist.",
          "type": "boolean"
        },
        "dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableDashboard"
            }
          ],
          "description": "The Dashboard to update."
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateLinkTemplateBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the LinkTemplate will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LinkTemplate does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LinkTemplate. If the specified configuration is valid, the endpoint returns a partial response without the LinkTemplate. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "link_template": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableLinkTemplate"
            }
          ],
          "description": "The LinkTemplate to update."
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateLogInternalMaterializedFieldBody": {
      "properties": {
        "create_if_missing": {
          "type": "boolean"
        },
        "dry_run": {
          "type": "boolean"
        },
        "log_internal_materialized_field": {
          "$ref": "#/definitions/configunstableLogInternalMaterializedField"
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateNoopEntityBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the NoopEntity will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the NoopEntity does not already exist.",
          "type": "boolean"
        },
        "noop_entity": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableNoopEntity"
            }
          ],
          "description": "The NoopEntity to update."
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateObjectDiscoveryRuleBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the ObjectDiscoveryRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the ObjectDiscoveryRule does not already exist.",
          "type": "boolean"
        },
        "object_discovery_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableObjectDiscoveryRule"
            }
          ],
          "description": "The ObjectDiscoveryRule to update."
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateSavedTraceSearchBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the SavedTraceSearch will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the SavedTraceSearch does not already exist.",
          "type": "boolean"
        },
        "saved_trace_search": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableSavedTraceSearch"
            }
          ],
          "description": "The SavedTraceSearch to update."
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateServiceBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the Service will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Service does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Service. If the specified configuration is valid, the endpoint returns a partial response without the Service. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "service": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableService"
            }
          ],
          "description": "The Service to update."
        }
      },
      "type": "object"
    },
    "ConfigUnstableUpdateTraceJaegerRemoteSamplingStrategyBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceJaegerRemoteSamplingStrategy. If the specified configuration is valid, the endpoint returns a partial response without the TraceJaegerRemoteSamplingStrategy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_jaeger_remote_sampling_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
            }
          ],
          "description": "The TraceJaegerRemoteSamplingStrategy to update."
        }
      },
      "type": "object"
    },
    "LogInternalMaterializedFieldMaterializedFieldStatus": {
      "enum": [
        "PENDING_MIGRATION",
        "MIGRATED",
        "PENDING_DELETION",
        "DELETED",
        "IGNORED"
      ],
      "type": "string"
    },
    "LogInternalMaterializedFieldMaterializedFieldType": {
      "enum": [
        "STRING",
        "LOW_CARDINALITY_STRING",
        "INT_32",
        "INT_64",
        "FLOAT_32",
        "FLOAT_64"
      ],
      "type": "string"
    },
    "NoopEntityNestedEnum": {
      "enum": [
        "ENABLED"
      ],
      "type": "string"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "ObjectDiscoveryRuleMetricRule": {
      "properties": {
        "expr": {
          "type": "string"
        },
        "objectLabels": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "objectMappingLabel": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy should apply.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
            }
          ],
          "description": "Probabilistic strategy to apply to traces matching this operation."
        }
      },
      "type": "object"
    },
    "SavedTraceSearchBetweenTimeFilter": {
      "properties": {
        "max_time": {
          "description": "End time of the search interval.",
          "format": "date-time",
          "type": "string"
        },
        "min_time": {
          "description": "Start time of the search interval.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchCloseToTimeFilter": {
      "properties": {
        "time": {
          "description": "Time around which the search will performed.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchRelativeTimeFilter": {
      "properties": {
        "end_relative_offset_secs": {
          "description": "The duration, in seconds, from now to the end of the search interval.",
          "format": "int32",
          "type": "integer"
        },
        "start_relative_offset_secs": {
          "description": "The duration, in seconds, from now to the beginning of the search interval.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "SavedTraceSearchTimeFilter": {
      "properties": {
        "between": {
          "allOf": [
            {
              "$ref": "#/definitions/SavedTraceSearchBetweenTimeFilter"
            }
          ],
          "description": "If set, limits the search to an interval defined in terms of two absolute timestamps."
        },
        "close_to": {
          "allOf": [
            {
              "$ref": "#/definitions/SavedTraceSearchCloseToTimeFilter"
            }
          ],
          "description": "If set, limits the search to an interval in proximity to a single timestamp."
        },
        "relative": {
          "allOf": [
            {
              "$ref": "#/definitions/SavedTraceSearchRelativeTimeFilter"
            }
          ],
          "description": "If set, limits the search to an interval defined in terms of relative offsets from now."
        }
      },
      "type": "object"
    },
    "SavedTraceSearchTraceSearch": {
      "properties": {
        "criteria": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceSearchFilter"
            }
          ],
          "description": "Filter that defines the semantics of traces to return in search results."
        },
        "time": {
          "allOf": [
            {
              "$ref": "#/definitions/SavedTraceSearchTimeFilter"
            }
          ],
          "description": "Filter that defines the time range to perform the search over."
        }
      },
      "type": "object"
    },
    "SeverityMappingSeverity": {
      "enum": [
        "CRITICAL"
      ],
      "type": "string"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION",
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "SyncPrometheusChangeLog": {
      "properties": {
        "diff": {
          "description": "TODO: do we want to keep diff in the public API?",
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "slug": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/SyncPrometheusChangeLogType"
        }
      },
      "type": "object"
    },
    "SyncPrometheusChangeLogType": {
      "enum": [
        "CREATED_NOTIFIER",
        "UPDATED_NOTIFIER",
        "DELETED_NOTIFIER",
        "CREATED_BUCKET",
        "UPDATED_BUCKET",
        "DELETED_BUCKET",
        "CREATED_COLLECTION",
        "UPDATED_COLLECTION",
        "DELETED_COLLECTION",
        "CREATED_NOTIFICATION_POLICY",
        "UPDATED_NOTIFICATION_POLICY",
        "DELETED_NOTIFICATION_POLICY",
        "CREATED_MONITOR",
        "UPDATED_MONITOR",
        "DELETED_MONITOR",
        "CREATED_RECORDING_RULE",
        "UPDATED_RECORDING_RULE",
        "DELETED_RECORDING_RULE"
      ],
      "type": "string"
    },
    "SyncPrometheusChronoConfig": {
      "properties": {
        "assign_monitor_slugs": {
          "description": "TODO: before configv1 - is this still required? does chronoctl set it?",
          "type": "boolean"
        },
        "collections_config": {
          "$ref": "#/definitions/ChronoConfigCollectionsConfig"
        },
        "exists_op_supported": {
          "description": "If true, alert rule expressions that are not in the form of \"expr op number\" (e.g. \"sum(stuff) \u003e 5\")\nwill be executed as-is.\nWithout this set, expressions will be converted to binary expressions (e.g. \"x \u003e y\" as \"(x - y) \u003e 0\").\n\nTODO: before configv1 - is this still required? does chronoctl set it?",
          "type": "boolean"
        },
        "group_across_severities": {
          "description": "If true, we set the the group_across_severities flag on notification policies to\ntrue, so that warn and critical notifications are grouped together.\n\nTODO:  i don't think we export this on notification policies in the public API,\n       we may need to figure out a better solution here (do we need to expose\n       in both, or do we need to update the comment to stop referring to the\n       option on the policy?)",
          "type": "boolean"
        },
        "infer_monitor_signals": {
          "description": "Controls whether we try to infer monitor signals from the alertmanager route tree.",
          "type": "boolean"
        },
        "monitor_signal_per_series": {
          "description": "If true, each monitor will not group alert notifications.",
          "type": "boolean"
        },
        "severity_label_name": {
          "description": "Customer-specific name of alert rule label used to determine severity.\nIf omitted, the Chronosphere default of \"severity\" is used.",
          "type": "string"
        },
        "severity_mappings": {
          "items": {
            "$ref": "#/definitions/ChronoConfigSeverityMapping"
          },
          "type": "array"
        },
        "use_collections": {
          "allOf": [
            {
              "$ref": "#/definitions/SyncPrometheusContainerType"
            }
          ],
          "description": "This determines which type of container is created to hold sync'd entities"
        }
      },
      "type": "object"
    },
    "SyncPrometheusContainerType": {
      "enum": [
        "COLLECTIONS",
        "BUCKETS"
      ],
      "title": "TODO: confirm naming with InfoModel team",
      "type": "string"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "per_operation_strategies": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
            }
          ],
          "description": "Applies an operation-granularity strategy. Exactly one of these strategies must be set."
        },
        "probabilistic_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
            }
          ],
          "description": "Applies a probabilistic strategy. Exactly one of these strategies must be set."
        },
        "rate_limiting_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
            }
          ],
          "description": "Applies a rate-limiting strategy. Exactly one of these strategies must be set."
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range [0, 1]) when specific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for ANY operation in the service, regardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the default sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range [0, 1] that defines the probability of sampling any trace.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "max": {
          "description": "Maximum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        },
        "min": {
          "description": "Minimum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "allOf": [
            {
              "$ref": "#/definitions/NumericFilterComparisonType"
            }
          ],
          "description": "The comparison operation to apply to an input against the given query value."
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterScopeFilter": {
      "properties": {
        "span_scopes": {
          "description": "Specifies the span filters that define which spans contribute to the metrics calculation.\nOnly spans matching these filters will be included in the metrics aggregation.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "duration": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterDurationFilter"
            }
          ],
          "description": "Matches the duration of the candidate span."
        },
        "error": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterBoolFilter"
            }
          ],
          "description": "Matches the error status of the candidate span."
        },
        "is_root_span": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterBoolFilter"
            }
          ],
          "description": "Matches the root span of a trace. For example, if the parent span has no child\nspans."
        },
        "match_type": {
          "allOf": [
            {
              "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
            }
          ],
          "description": "If `INCLUDE`, includes all traces that have at least one (or `span_count`)\nspans matching the query. If `EXCLUDE`, excludes all traces that have at least\none (or `span_count`) spans matching the query."
        },
        "operation": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "Matches the operation of the candidate span."
        },
        "parent_operation": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "If not a root span, matches the operation of the candidate span's parent span"
        },
        "parent_service": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "If not a root span, matches the service of the candidate span's parent span."
        },
        "service": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "Matches the service of the candidate span."
        },
        "span_count": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterCountFilter"
            }
          ],
          "description": "Defines the number of spans that must match the criteria defined by the span\nquery. Defaults to requiring that at least one span matches the span query."
        },
        "tags": {
          "description": "Matches the tags of the candidate span.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "in_values": {
          "description": "Values the filter tests against when using `IN` or `NOT_IN` match type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "match": {
          "allOf": [
            {
              "$ref": "#/definitions/StringFilterStringFilterMatchType"
            }
          ],
          "description": "Specifies the comparison operator for the query. If `EXACT`, compared strings\nmust have the exact value of the query value."
        },
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key or name of the span tag that this filter inspects.",
          "type": "string"
        },
        "numeric_value": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterNumericFilter"
            }
          ],
          "description": "If the query matches the tag with the specified key, and the value type is\n`numeric`, specifies the matcher used to evaluate the span tag value."
        },
        "value": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "If the query matches the tag with the specified key, and the value type is a\n`string`, specifies the matcher used to evaluate the span tag value."
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterDurationFilter"
            }
          ],
          "description": "Matches traces based on the duration of the entire trace."
        },
        "error": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterBoolFilter"
            }
          ],
          "description": "Matches traces based on the top-level error status."
        }
      },
      "type": "object"
    },
    "TraceTopTagConfigTraceTopTag": {
      "properties": {
        "description": {
          "description": "Human readable description of the tag.",
          "type": "string"
        },
        "tag_name": {
          "description": "Tag name that uniquely identifies a tag.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "apiError": {
      "properties": {
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableCreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableDashboard"
            }
          ],
          "description": "The Dashboard to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableCreateLinkTemplateRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LinkTemplate. If the specified configuration is valid, the endpoint returns a partial response without the LinkTemplate. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "link_template": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableLinkTemplate"
            }
          ],
          "description": "The LinkTemplate to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableCreateLogInternalMaterializedFieldRequest": {
      "properties": {
        "dry_run": {
          "type": "boolean"
        },
        "log_internal_materialized_field": {
          "$ref": "#/definitions/configunstableLogInternalMaterializedField"
        }
      },
      "type": "object"
    },
    "configunstableCreateLogInternalMaterializedFieldResponse": {
      "properties": {
        "log_internal_materialized_field": {
          "$ref": "#/definitions/configunstableLogInternalMaterializedField"
        }
      },
      "type": "object"
    },
    "configunstableCreateNoopEntityRequest": {
      "properties": {
        "noop_entity": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableNoopEntity"
            }
          ],
          "description": "The NoopEntity to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableCreateObjectDiscoveryRuleRequest": {
      "properties": {
        "object_discovery_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableObjectDiscoveryRule"
            }
          ],
          "description": "The ObjectDiscoveryRule to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateObjectDiscoveryRuleResponse": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        }
      },
      "type": "object"
    },
    "configunstableCreateSavedTraceSearchRequest": {
      "properties": {
        "saved_trace_search": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableSavedTraceSearch"
            }
          ],
          "description": "The SavedTraceSearch to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableCreateServiceRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Service. If the specified configuration is valid, the endpoint returns a partial response without the Service. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "service": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableService"
            }
          ],
          "description": "The Service to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceJaegerRemoteSamplingStrategy. If the specified configuration is valid, the endpoint returns a partial response without the TraceJaegerRemoteSamplingStrategy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_jaeger_remote_sampling_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
            }
          ],
          "description": "The TraceJaegerRemoteSamplingStrategy to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTailSamplingRulesRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceTailSamplingRules. If the specified configuration is valid, the endpoint returns a partial response without the TraceTailSamplingRules. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_tail_sampling_rules": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableTraceTailSamplingRules"
            }
          ],
          "description": "The TraceTailSamplingRules to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTopTagConfigRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceTopTagConfig. If the specified configuration is valid, the endpoint returns a partial response without the TraceTopTagConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_top_tag_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableTraceTopTagConfig"
            }
          ],
          "description": "The TraceTopTagConfig to create."
        }
      },
      "type": "object"
    },
    "configunstableCreateTraceTopTagConfigResponse": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        }
      },
      "type": "object"
    },
    "configunstableDashboard": {
      "properties": {
        "collection_slug": {
          "description": "Required slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the dashboard.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Dashboard. You can modify this value after the Dashboard is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Dashboard. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Dashboard is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configunstableDefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Whether to override the default sample rate",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configunstableDeleteDashboardResponse": {
      "type": "object"
    },
    "configunstableDeleteLinkTemplateResponse": {
      "type": "object"
    },
    "configunstableDeleteLogInternalMaterializedFieldResponse": {
      "type": "object"
    },
    "configunstableDeleteNoopEntityResponse": {
      "properties": {
        "not_hidden": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configunstableDeleteObjectDiscoveryRuleResponse": {
      "type": "object"
    },
    "configunstableDeleteSavedTraceSearchResponse": {
      "type": "object"
    },
    "configunstableDeleteServiceResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configunstableDeleteTraceTopTagConfigResponse": {
      "type": "object"
    },
    "configunstableLinkTemplate": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LinkTemplate was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "name": {
          "description": "Unique name of the LinkTemplate. Used as the link text.",
          "type": "string"
        },
        "slug": {
          "description": "Unique slug identifying the LinkTemplate.",
          "type": "string"
        },
        "ui_component": {
          "description": "Link template is scoped to the specified string representing a UI component here.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LinkTemplate was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "url_template": {
          "description": "URL template.",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configunstableListDashboardsResponse": {
      "properties": {
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configunstableDashboard"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListLinkTemplatesResponse": {
      "properties": {
        "link_templates": {
          "items": {
            "$ref": "#/definitions/configunstableLinkTemplate"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListLogInternalMaterializedFieldsResponse": {
      "properties": {
        "log_internal_materialized_fields": {
          "items": {
            "$ref": "#/definitions/configunstableLogInternalMaterializedField"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListNoopEntitiesResponse": {
      "properties": {
        "noop_entities": {
          "items": {
            "$ref": "#/definitions/configunstableNoopEntity"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListObjectDiscoveryRulesResponse": {
      "properties": {
        "object_discovery_rules": {
          "items": {
            "$ref": "#/definitions/configunstableObjectDiscoveryRule"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configunstableListSavedTraceSearchesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "saved_trace_searches": {
          "description": "Found saved trace searches.",
          "items": {
            "$ref": "#/definitions/configunstableSavedTraceSearch"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListServicesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "services": {
          "items": {
            "$ref": "#/definitions/configunstableService"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableLogInternalMaterializedField": {
      "properties": {
        "column_name": {
          "description": "Name of the clickhouse column that this field maps to. Its an actual value that is used for the queries.",
          "type": "string"
        },
        "created_at": {
          "format": "date-time",
          "type": "string"
        },
        "materialize_expression": {
          "description": "Materialize expression allows providing more complex instructions\nhow to get field value, for example using conditions, instead\nof simply targeting field defined by targeted_field.\nIf materialize_expression is provided targeted_field should be empty.",
          "type": "string"
        },
        "name": {
          "description": "Name of the entity.",
          "type": "string"
        },
        "slug": {
          "description": "Unique slug identifying the LogInternalMaterializedField.",
          "type": "string"
        },
        "status": {
          "allOf": [
            {
              "$ref": "#/definitions/LogInternalMaterializedFieldMaterializedFieldStatus"
            }
          ],
          "description": "Status of the materialized field in the migration process"
        },
        "targeted_field": {
          "description": "Targeted field defines a field in a payload that should be materialized.",
          "type": "string"
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/LogInternalMaterializedFieldMaterializedFieldType"
            }
          ],
          "description": "Type of materialized field like STRING or LOW_CARDINALITY_STRING or NUMBER."
        },
        "updated_at": {
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableNoopEntity": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the NoopEntity was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "enum": {
          "$ref": "#/definitions/configunstableNoopEnum"
        },
        "name": {
          "description": "The name of the NoopEntity. You can modify this value after the NoopEntity is created.",
          "type": "string"
        },
        "nested_enum": {
          "$ref": "#/definitions/NoopEntityNestedEnum"
        },
        "slug": {
          "description": "The unique identifier of the NoopEntity. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the NoopEntity is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NoopEntity was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configunstableNoopEnum": {
      "enum": [
        "ACTIVE"
      ],
      "type": "string"
    },
    "configunstableObjectDiscoveryRule": {
      "properties": {
        "metric": {
          "$ref": "#/definitions/ObjectDiscoveryRuleMetricRule"
        },
        "name": {
          "description": "The name of the ObjectDiscoveryRule. You can modify this value after the ObjectDiscoveryRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the ObjectDiscoveryRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the ObjectDiscoveryRule is created.",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configunstableReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableReadLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableReadLogInternalMaterializedFieldResponse": {
      "properties": {
        "log_internal_materialized_field": {
          "$ref": "#/definitions/configunstableLogInternalMaterializedField"
        }
      },
      "type": "object"
    },
    "configunstableReadNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableReadObjectDiscoveryRuleResponse": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        }
      },
      "type": "object"
    },
    "configunstableReadSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableReadTraceTopTagConfigResponse": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        }
      },
      "type": "object"
    },
    "configunstableSavedTraceSearch": {
      "properties": {
        "comparison": {
          "allOf": [
            {
              "$ref": "#/definitions/SavedTraceSearchTraceSearch"
            }
          ],
          "description": "Optionally, a comparison trace search."
        },
        "created_at": {
          "description": "Timestamp of when the SavedTraceSearch was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "name": {
          "description": "The name of the SavedTraceSearch. You can modify this value after the SavedTraceSearch is created.",
          "type": "string"
        },
        "search": {
          "allOf": [
            {
              "$ref": "#/definitions/SavedTraceSearchTraceSearch"
            }
          ],
          "description": "The definition of the trace search."
        },
        "slug": {
          "description": "The unique identifier of the SavedTraceSearch. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the SavedTraceSearch is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the SavedTraceSearch was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configunstableService": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "derived_name": {
          "description": "Required telemetry name of the service.",
          "type": "string"
        },
        "description": {
          "description": "Optional description of the service collection.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Service. You can modify this value after the Service is created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service collection.\nThis is optional if the collection does not contain monitors or all of its monitors explicitly reference a policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Service. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Service is created.",
          "type": "string"
        },
        "team_slug": {
          "description": "Required slug of the team the service collection belongs to.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configunstableSyncPrometheusRequest": {
      "properties": {
        "alertmanager_yaml": {
          "type": "string"
        },
        "alertmanager_yaml_gzip": {
          "format": "byte",
          "type": "string"
        },
        "chrono_config": {
          "$ref": "#/definitions/SyncPrometheusChronoConfig"
        },
        "dry_run": {
          "type": "boolean"
        },
        "rules_yaml": {
          "type": "string"
        },
        "rules_yaml_gzip": {
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableSyncPrometheusResponse": {
      "properties": {
        "changes": {
          "items": {
            "$ref": "#/definitions/SyncPrometheusChangeLog"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configunstableTraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "applied_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
            }
          ],
          "description": "The strategy to apply for JaegerRemoteSampler-enabled agents running in the named service."
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "name": {
          "description": "The name of the TraceJaegerRemoteSamplingStrategy. You can modify this value after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This must match the slug and name fields.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the TraceJaegerRemoteSamplingStrategy. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configunstableTraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "created_at": {
          "description": "When the rule was created (novel system_name)",
          "format": "date-time",
          "type": "string"
        },
        "filter": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceSearchFilter"
            }
          ],
          "description": "Filter criteria applied to each trace, to determine whether the trace is a match"
        },
        "name": {
          "description": "A human-readable name of the rule, which summarizes what it's for",
          "type": "string"
        },
        "sample_rate": {
          "description": "A fraction of traces to keep, which should be a number between 0 and 1, inclusive",
          "format": "double",
          "type": "number"
        },
        "system_name": {
          "description": "Value used as the metric label value for metrics emitted relating to this rule.",
          "type": "string"
        },
        "updated_at": {
          "description": "When the rule was updated (existing system_name)",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableTraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_sample_rate": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableDefaultSampleRate"
            }
          ],
          "description": "Optional. By default, all traces not matching rules are kept.\nThe user may override this by providing a default sample rate message."
        },
        "rules": {
          "description": "Optional. A list of rules, evaluated in order until a match is found,\nand the sample rate applied, or else the default sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configunstableTraceTailSamplingRule"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Set in API responses.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableTraceTopTagConfig": {
      "description": "TraceTopTagConfig is a singleton configuration object that specifies the\nconfiguration for top tracing tags.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the TraceTopTagConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "source_client": {
          "type": "string"
        },
        "top_tags": {
          "description": "The list of \"top\" tags. Must be unique by tag_name.",
          "items": {
            "$ref": "#/definitions/TraceTopTagConfigTraceTopTag"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceTopTagConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configunstableUpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configunstableDashboard"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLinkTemplateResponse": {
      "properties": {
        "link_template": {
          "$ref": "#/definitions/configunstableLinkTemplate"
        }
      },
      "type": "object"
    },
    "configunstableUpdateLogInternalMaterializedFieldResponse": {
      "properties": {
        "log_internal_materialized_field": {
          "$ref": "#/definitions/configunstableLogInternalMaterializedField"
        }
      },
      "type": "object"
    },
    "configunstableUpdateNoopEntityResponse": {
      "properties": {
        "noop_entity": {
          "$ref": "#/definitions/configunstableNoopEntity"
        }
      },
      "type": "object"
    },
    "configunstableUpdateObjectDiscoveryRuleResponse": {
      "properties": {
        "object_discovery_rule": {
          "$ref": "#/definitions/configunstableObjectDiscoveryRule"
        }
      },
      "type": "object"
    },
    "configunstableUpdateSavedTraceSearchResponse": {
      "properties": {
        "saved_trace_search": {
          "$ref": "#/definitions/configunstableSavedTraceSearch"
        }
      },
      "type": "object"
    },
    "configunstableUpdateServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configunstableService"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configunstableTraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceTailSamplingRules will be created if it does not already exist. If `false`, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceTailSamplingRules. If the specified configuration is valid, the endpoint returns a partial response without the TraceTailSamplingRules. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_tail_sampling_rules": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableTraceTailSamplingRules"
            }
          ],
          "description": "The TraceTailSamplingRules to update."
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configunstableTraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTopTagConfigRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceTopTagConfig will be created if it does not already exist. If `false`, an error will be returned if the TraceTopTagConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceTopTagConfig. If the specified configuration is valid, the endpoint returns a partial response without the TraceTopTagConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_top_tag_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configunstableTraceTopTagConfig"
            }
          ],
          "description": "The TraceTopTagConfig to update."
        }
      },
      "type": "object"
    },
    "configunstableUpdateTraceTopTagConfigResponse": {
      "properties": {
        "trace_top_tag_config": {
          "$ref": "#/definitions/configunstableTraceTopTagConfig"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "An opaque page token that identifies the next page of items that the\nclient should request. An empty value indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "scope_filter": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterScopeFilter"
            }
          ],
          "description": "Scope filter that defines which spans within matching traces contribute to metrics calculation."
        },
        "span": {
          "description": "Specifies the span conditions to match on. All conditions must be true in a\nsingle span for the span to be considered a match. If `span_count` is specified,\nthe number of spans within the trace that match span conditions must be within\n`[min, max]`. You can specify multiple span conditions, and each can be\nsatisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        },
        "trace": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterTraceFilter"
            }
          ],
          "description": "Trace-level filter criteria (effectively matching the root span)."
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\n\u003cb\u003eWARNING: This API is unstable and is meant for experimentation only. Do not\nuse this API in production. The endpoints and schemas referenced in this\ndocumentation will be changed or removed without notice and without any\nbackwards compatibility guarantee. Note that even though this API is unstable,\nit is still connected to production data, so use with caution.\u003c/b\u003e",
    "title": "Config Unstable API",
    "version": "UNSTABLE"
  },
  "paths": {
    "/api/unstable/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/unstable/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/unstable/config/link-templates": {
      "get": {
        "operationId": "ListLinkTemplates",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LinkTemplate with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LinkTemplate with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by ui_component, where any LinkTemplate with a matching ui_component in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "ui_components",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListLinkTemplatesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "post": {
        "operationId": "CreateLinkTemplate",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateLinkTemplateRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot create the LinkTemplate because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LinkTemplate because there is a conflict with an existing LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      }
    },
    "/api/unstable/config/link-templates/{slug}": {
      "delete": {
        "operationId": "DeleteLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LinkTemplate because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "get": {
        "operationId": "ReadLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadLinkTemplateResponse"
            }
          },
          "404": {
            "description": "Cannot read the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      },
      "put": {
        "operationId": "UpdateLinkTemplate",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateLinkTemplateBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateLinkTemplateResponse"
            }
          },
          "400": {
            "description": "Cannot update the LinkTemplate because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LinkTemplate because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LinkTemplate because there is a conflict with an existing LinkTemplate.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LinkTemplate"
        ]
      }
    },
    "/api/unstable/config/noop-entities": {
      "post": {
        "operationId": "CreateNoopEntity",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateNoopEntityRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NoopEntity.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot create the NoopEntity because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NoopEntity because there is a conflict with an existing NoopEntity.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      }
    },
    "/api/unstable/config/noop-entities/{slug}": {
      "delete": {
        "operationId": "DeleteNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NoopEntity because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      },
      "get": {
        "operationId": "ReadNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadNoopEntityResponse"
            }
          },
          "404": {
            "description": "Cannot read the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      },
      "put": {
        "operationId": "UpdateNoopEntity",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateNoopEntityBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NoopEntity.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateNoopEntityResponse"
            }
          },
          "400": {
            "description": "Cannot update the NoopEntity because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NoopEntity because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NoopEntity because there is a conflict with an existing NoopEntity.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NoopEntity"
        ]
      }
    },
    "/api/unstable/config/object-discovery-rules": {
      "get": {
        "operationId": "ListObjectDiscoveryRule",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListObjectDiscoveryRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      },
      "post": {
        "operationId": "CreateObjectDiscoveryRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateObjectDiscoveryRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateObjectDiscoveryRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the ObjectDiscoveryRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ObjectDiscoveryRule because there is a conflict with an existing ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      }
    },
    "/api/unstable/config/object-discovery-rules/{slug}": {
      "delete": {
        "operationId": "DeleteObjectDiscoveryRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteObjectDiscoveryRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ObjectDiscoveryRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ObjectDiscoveryRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      },
      "get": {
        "operationId": "ReadObjectDiscoveryRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadObjectDiscoveryRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the ObjectDiscoveryRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      },
      "put": {
        "operationId": "UpdateObjectDiscoveryRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateObjectDiscoveryRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateObjectDiscoveryRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the ObjectDiscoveryRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ObjectDiscoveryRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the ObjectDiscoveryRule because there is a conflict with an existing ObjectDiscoveryRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ObjectDiscoveryRule"
        ]
      }
    },
    "/api/unstable/config/saved-trace-searches": {
      "get": {
        "operationId": "ListSavedTraceSearches",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any SavedTraceSearch with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any SavedTraceSearch with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional filter: creator email address.",
            "in": "query",
            "name": "created_by",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListSavedTraceSearchesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "post": {
        "description": "***\nSaved Trace Searches\n***",
        "operationId": "CreateSavedTraceSearch",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateSavedTraceSearchRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot create the SavedTraceSearch because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the SavedTraceSearch because there is a conflict with an existing SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      }
    },
    "/api/unstable/config/saved-trace-searches/{slug}": {
      "delete": {
        "operationId": "DeleteSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot delete the SavedTraceSearch because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "get": {
        "operationId": "ReadSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadSavedTraceSearchResponse"
            }
          },
          "404": {
            "description": "Cannot read the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      },
      "put": {
        "operationId": "UpdateSavedTraceSearch",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateSavedTraceSearchBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateSavedTraceSearchResponse"
            }
          },
          "400": {
            "description": "Cannot update the SavedTraceSearch because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the SavedTraceSearch because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the SavedTraceSearch because there is a conflict with an existing SavedTraceSearch.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SavedTraceSearch"
        ]
      }
    },
    "/api/unstable/config/services": {
      "get": {
        "operationId": "ListServices",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Service with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Service with a matching team_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Service with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get services that directly reference notifications policies by the referenced policy slugs.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListServicesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "post": {
        "operationId": "CreateService",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateServiceRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Service.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateServiceResponse"
            }
          },
          "400": {
            "description": "Cannot create the Service because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Service because there is a conflict with an existing Service.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/unstable/config/services/{slug}": {
      "delete": {
        "operationId": "DeleteService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteServiceResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Service because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      },
      "put": {
        "operationId": "UpdateService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateServiceBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Service.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateServiceResponse"
            }
          },
          "400": {
            "description": "Cannot update the Service because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Service because there is a conflict with an existing Service.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/unstable/config/sync-prometheus": {
      "post": {
        "description": "***\nSync Prometheus Configuration\n***",
        "operationId": "SyncPrometheus",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableSyncPrometheusRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableSyncPrometheusResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "SyncPrometheus"
        ]
      }
    },
    "/api/unstable/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/unstable/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigUnstableUpdateTraceJaegerRemoteSamplingStrategyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/unstable/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    },
    "/api/unstable/config/trace-top-tag-config": {
      "delete": {
        "operationId": "DeleteTraceTopTagConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableDeleteTraceTopTagConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTopTagConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTopTagConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      },
      "get": {
        "operationId": "ReadTraceTopTagConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configunstableReadTraceTopTagConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTopTagConfig because TraceTopTagConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      },
      "post": {
        "operationId": "CreateTraceTopTagConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTopTagConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTopTagConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableCreateTraceTopTagConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTopTagConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTopTagConfig because there is a conflict with an existing TraceTopTagConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTopTagConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTopTagConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTopTagConfig.",
            "schema": {
              "$ref": "#/definitions/configunstableUpdateTraceTopTagConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTopTagConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTopTagConfig because TraceTopTagConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTopTagConfig"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "security": [
    {
      "ApiKeyAuth": []
    }
  ],
  "securityDefinitions": {
    "ApiKeyAuth": {
      "description": "Chronosphere API token",
      "in": "header",
      "name": "API-Token",
      "type": "apiKey"
    }
  },
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigUnstable"
    }
  ]
}