{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "AllocationFixedValue": {
      "properties": {
        "license": {
          "$ref": "#/definitions/ResourcePoolsLicense"
        },
        "value": {
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AllocationThresholds": {
      "description": "Thresholds define strict quota limits for each metrics license.",
      "properties": {
        "all_priorities": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourcePoolsAllocationThreshold"
            }
          ],
          "description": "Threshold limit that defines when to drop new metrics in the pool. This\nthreshold applies to all priorities of metrics: high, default, and low. This\nfield must be set, and have a value equal to or greater than other priority\nfields."
        },
        "default_and_low_priority": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourcePoolsAllocationThreshold"
            }
          ],
          "description": "Threshold limit that defines when to drop new metrics in the pool that are\ndefault and low priority. If this field is set, its value must be equal to\nor greater than the value set for `low_priority`."
        },
        "license": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourcePoolsLicense"
            }
          ],
          "description": "License to which these thresholds apply. If you configure\n`priority_thresholds`, only the `PERSISTED_CARDINALITY_STANDARD` and\n`PERSISTED_CARDINALITY_HISTOGRAM` licenses are supported."
        },
        "low_priority": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourcePoolsAllocationThreshold"
            }
          ],
          "description": "Threshold limit that defines when to drop new metrics in the pool that are\nonly low priority. If this field is set, its value must be equal to or\nlesser than other priority fields."
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzurePrincipal": {
      "properties": {
        "client_id": {
          "description": "Specifies the OAuth2 client ID of the managed identity principal.",
          "type": "string"
        },
        "tenant_id": {
          "description": "Specifies the ID of the Azure tenant that hosts the managed identity principal.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzureResourceType": {
      "properties": {
        "metric_names": {
          "description": "List of metric names to be targeted (these apply to this resource type; use empty for all metrics).",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "description": "Name of the resource type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AzureMetricsIntegrationAzureScrapeConfig": {
      "properties": {
        "locations": {
          "description": "Locations to be ingested for this integration (these apply to all subscriptions; use empty for all locations).",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "resource_types": {
          "description": "Metric groups to be ingested for this integration.",
          "items": {
            "$ref": "#/definitions/AzureMetricsIntegrationAzureResourceType"
          },
          "type": "array"
        },
        "subscription_ids": {
          "description": "Subscriptions to be targeted for this integration (use empty for all subscriptions).",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ConditionOp": {
      "enum": [
        "GEQ",
        "GT",
        "LEQ",
        "LT",
        "EQ",
        "NEQ",
        "EXISTS",
        "NOT_EXISTS"
      ],
      "type": "string"
    },
    "ConfigV1CreateServiceAttributeBody": {
      "properties": {
        "dry_run": {
          "type": "boolean"
        },
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateAzureMetricsIntegrationBody": {
      "properties": {
        "azure_metrics_integration": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1AzureMetricsIntegration"
            }
          ],
          "description": "The AzureMetricsIntegration to update."
        },
        "create_if_missing": {
          "description": "If `true`, the AzureMetricsIntegration will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the AzureMetricsIntegration does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the AzureMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the AzureMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateBucketBody": {
      "properties": {
        "bucket": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Bucket"
            }
          ],
          "description": "The Bucket to update."
        },
        "create_if_missing": {
          "description": "If `true`, the Bucket will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Bucket does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Bucket. If the specified configuration is valid, the endpoint returns a partial response without the Bucket. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateClassicDashboardBody": {
      "properties": {
        "classic_dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GrafanaDashboard"
            }
          ],
          "description": "The GrafanaDashboard to update."
        },
        "create_if_missing": {
          "description": "If `true`, the GrafanaDashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateCollectionBody": {
      "properties": {
        "collection": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Collection"
            }
          ],
          "description": "The Collection to update."
        },
        "create_if_missing": {
          "description": "If `true`, the Collection will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Collection does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Collection. If the specified configuration is valid, the endpoint returns a partial response without the Collection. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateConsumptionBudgetBody": {
      "properties": {
        "consumption_budget": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ConsumptionBudget"
            }
          ],
          "description": "The ConsumptionBudget to update."
        },
        "create_if_missing": {
          "description": "If `true`, the ConsumptionBudget will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the ConsumptionBudget does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the ConsumptionBudget. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionBudget. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDashboardBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the Dashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dashboard does not already exist.",
          "type": "boolean"
        },
        "dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Dashboard"
            }
          ],
          "description": "The Dashboard to update."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Dashboard. If the specified configuration is valid, the endpoint returns a partial response without the Dashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDatasetBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the Dataset will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Dataset does not already exist.",
          "type": "boolean"
        },
        "dataset": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Dataset"
            }
          ],
          "description": "The Dataset to update."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Dataset. If the specified configuration is valid, the endpoint returns a partial response without the Dataset. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedLabelBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the DerivedLabel will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DerivedLabel does not already exist.",
          "type": "boolean"
        },
        "derived_label": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DerivedLabel"
            }
          ],
          "description": "The DerivedLabel to update."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the DerivedLabel. If the specified configuration is valid, the endpoint returns a partial response without the DerivedLabel. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDerivedMetricBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the DerivedMetric will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DerivedMetric does not already exist.",
          "type": "boolean"
        },
        "derived_metric": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DerivedMetric"
            }
          ],
          "description": "The DerivedMetric to update."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the DerivedMetric. If the specified configuration is valid, the endpoint returns a partial response without the DerivedMetric. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateDropRuleBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the DropRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the DropRule does not already exist.",
          "type": "boolean"
        },
        "drop_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DropRule"
            }
          ],
          "description": "The DropRule to update."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the DropRule. If the specified configuration is valid, the endpoint returns a partial response without the DropRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGcpMetricsIntegrationBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the GcpMetricsIntegration will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GcpMetricsIntegration does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the GcpMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the GcpMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "gcp_metrics_integration": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GcpMetricsIntegration"
            }
          ],
          "description": "The GcpMetricsIntegration to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateGrafanaDashboardBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the GrafanaDashboard will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the GrafanaDashboard does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "grafana_dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GrafanaDashboard"
            }
          ],
          "description": "The GrafanaDashboard to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleActionBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the LogScaleAction will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LogScaleAction does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogScaleAction. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAction. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_scale_action": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogScaleAction"
            }
          ],
          "description": "The LogScaleAction to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateLogScaleAlertBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the LogScaleAlert will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the LogScaleAlert does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogScaleAlert. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAlert. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_scale_alert": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogScaleAlert"
            }
          ],
          "description": "The LogScaleAlert to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMappingRuleBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the MappingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the MappingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the MappingRule. If the specified configuration is valid, the endpoint returns a partial response without the MappingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "mapping_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1MappingRule"
            }
          ],
          "description": "The MappingRule to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMonitorBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the Monitor will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Monitor does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Monitor. If the specified configuration is valid, the endpoint returns a partial response without the Monitor. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "monitor": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Monitor"
            }
          ],
          "description": "The Monitor to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateMutingRuleBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the MutingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the MutingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the MutingRule. If the specified configuration is valid, the endpoint returns a partial response without the MutingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "muting_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1MutingRule"
            }
          ],
          "description": "The MutingRule to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotificationPolicyBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the NotificationPolicy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the NotificationPolicy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the NotificationPolicy. If the specified configuration is valid, the endpoint returns a partial response without the NotificationPolicy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "notification_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1NotificationPolicy"
            }
          ],
          "description": "The NotificationPolicy to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateNotifierBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the Notifier will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Notifier does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Notifier. If the specified configuration is valid, the endpoint returns a partial response without the Notifier. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "notifier": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Notifier"
            }
          ],
          "description": "The Notifier to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRecordingRuleBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the RecordingRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the RecordingRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the RecordingRule. If the specified configuration is valid, the endpoint returns a partial response without the RecordingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "recording_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RecordingRule"
            }
          ],
          "description": "The RecordingRule to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateRollupRuleBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the RollupRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the RollupRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the RollupRule. If the specified configuration is valid, the endpoint returns a partial response without the RollupRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "rollup_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RollupRule"
            }
          ],
          "description": "The RollupRule to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateSLOBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the SLO will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the SLO does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the SLO. If the specified configuration is valid, the endpoint returns a partial response without the SLO. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "slo": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1SLO"
            }
          ],
          "description": "The SLO to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateServiceAttributeBody": {
      "properties": {
        "create_if_missing": {
          "type": "boolean"
        },
        "dry_run": {
          "type": "boolean"
        },
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTeamBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the Team will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the Team does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the Team. If the specified configuration is valid, the endpoint returns a partial response without the Team. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "team": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Team"
            }
          ],
          "description": "The Team to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceBehaviorBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceBehavior will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceBehavior does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceBehavior. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehavior. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_behavior": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceBehavior"
            }
          ],
          "description": "The TraceBehavior to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceJaegerRemoteSamplingStrategy will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceJaegerRemoteSamplingStrategy does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceJaegerRemoteSamplingStrategy. If the specified configuration is valid, the endpoint returns a partial response without the TraceJaegerRemoteSamplingStrategy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_jaeger_remote_sampling_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
            }
          ],
          "description": "The TraceJaegerRemoteSamplingStrategy to update."
        }
      },
      "type": "object"
    },
    "ConfigV1UpdateTraceMetricsRuleBody": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceMetricsRule will be created if it does not already exist, identified by `slug`. If `false`, an error will be returned if the TraceMetricsRule does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceMetricsRule. If the specified configuration is valid, the endpoint returns a partial response without the TraceMetricsRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_metrics_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceMetricsRule"
            }
          ],
          "description": "The TraceMetricsRule to update."
        }
      },
      "type": "object"
    },
    "ConstructedLabelValueDefinition": {
      "properties": {
        "filters": {
          "description": "Determine when to apply `name_mappings`, filtering out all other values.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetAlertActionConfig": {
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional annotations to set on the generated monitor. By default, the\nmonitors already contain \"description\", \"dashboard\", \"resource\",\n\"consumption_budget_slug\", \"threshold_type\", and \"partition\" annotations.\nSetting any of these annotations will override its default value.",
          "type": "object"
        },
        "instant_rate_sustain_secs": {
          "description": "How long instant rate consumption must sustain above the threshold in\norder to fire an alert. By default, the sustain is 0: any consumption\nover the threshold will fire an alert.",
          "format": "int32",
          "type": "integer"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional labels to set on the generated monitor, which can be used for\nnotification routing. The following labels are reserved and cannot be\noverride: \"resource\", \"partition\", and \"threshold_type\".",
          "type": "object"
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetPriority": {
      "properties": {
        "filters": {
          "description": "Criteria that defines which data matches the `priority`. Filters are\nconcatenated together as implied `AND` operators. A request must match every\nfilter to match the `priority`.",
          "items": {
            "$ref": "#/definitions/ConsumptionBudgetPriorityFilter"
          },
          "type": "array"
        },
        "priority": {
          "description": "Priority order that determines when to drop data. A priority of `10` is\ndropped first, and a priority of `1` is dropped last.",
          "format": "int32",
          "type": "integer"
        }
      },
      "required": [
        "filters",
        "priority"
      ],
      "type": "object"
    },
    "ConsumptionBudgetPriorityFilter": {
      "properties": {
        "dataset_slug": {
          "description": "If set, matches incoming data that belongs to the specified dataset.\nThe dataset type must match the budget resource. For example,\n`resource=LOG_PERSISTED_BYTES`, then the dataset type must be\n`type=LOGS`.\n\nExactly one of `dataset_slug` or `log_filter` must be set.",
          "type": "string"
        },
        "log_filter": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogSearchFilter"
            }
          ],
          "description": "If set, matches incoming log data by log query. This field is only\nvalid for `resource=LOG_*` budgets.\n\nExactly one of `dataset_slug` or `log_filter` must be set."
        }
      },
      "type": "object"
    },
    "ConsumptionBudgetThresholdAction": {
      "enum": [
        "ALERT_WARN",
        "ALERT_CRITICAL",
        "DROP"
      ],
      "type": "string"
    },
    "ConsumptionBudgetThresholdType": {
      "enum": [
        "DAILY_VOLUME",
        "INSTANT_RATE",
        "WEEKLY_VOLUME",
        "MONTHLY_VOLUME",
        "HOURLY_VOLUME",
        "ROLLING_1_HOUR_VOLUME",
        "ROLLING_3_HOUR_VOLUME"
      ],
      "type": "string"
    },
    "ConsumptionConfigPartition": {
      "properties": {
        "filters": {
          "description": "Criteria that defines which data matches the `partition`. Filters are\nconcatenated together as implied `AND` operators. A request must match every\nfilter to match the `partition`.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartitionFilter"
          },
          "type": "array"
        },
        "name": {
          "description": "Name of the partition. Must be unique within the parent partition. You can\nmodify this value after the partition is created.",
          "type": "string"
        },
        "partitions": {
          "description": "Optional. Child partitions of this partition. If set, requests that match the\ncurrent partition are allocated to the first child partition that matches.\nRequests that don't match any child partition are assigned to an implicit `default`\nchild partition.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartition"
          },
          "type": "array"
        },
        "slug": {
          "description": "Immutable identifier of the partition. Must be unique within the parent\npartition. You can't modify this value after the partition is created.",
          "type": "string"
        }
      },
      "required": [
        "filters"
      ],
      "type": "object"
    },
    "ConsumptionConfigPartitionFilter": {
      "properties": {
        "conditions": {
          "description": "Conditions for the query to match.",
          "items": {
            "$ref": "#/definitions/PartitionFilterCondition"
          },
          "type": "array"
        },
        "operator": {
          "allOf": [
            {
              "$ref": "#/definitions/FilterOperator"
            }
          ],
          "description": "Specifies the match operator for the request:\n- `IN`: the request must match at least one of the conditions.\n- `NOT_IN`: the request must not match any of the conditions."
        }
      },
      "required": [
        "operator"
      ],
      "type": "object"
    },
    "DatasetDatasetConfiguration": {
      "properties": {
        "log_dataset": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogDataset"
            }
          ],
          "description": "If the dataset type is `LOGS`, this configuration defines the semantics for\nthe log dataset."
        },
        "trace_dataset": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceDataset"
            }
          ],
          "description": "If the dataset type is `TRACES`, this configuration defines the semantics for\nthe trace dataset."
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/DatasetDatasetType"
            }
          ],
          "description": "The type of dataset."
        }
      },
      "type": "object"
    },
    "DatasetDatasetType": {
      "enum": [
        "TRACES",
        "LOGS"
      ],
      "type": "string"
    },
    "DefinitionBurnRateDefinition": {
      "properties": {
        "budget": {
          "description": "The amount of allowed errors during a given time window, expressed as a\npercentage of the error budget. Must be a value between `0.0` and `100.0`,\nexclusive.",
          "example": "50.0",
          "format": "double",
          "type": "number"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to attach when this burn rate triggers. If you add these labels to\n`signal_groupings`, you can route them in the notification policy, and can\nroute different burn rates to other notifiers.",
          "type": "object"
        },
        "severity": {
          "description": "Defines the alert severity level, which can only be one of `critical` or\n`warn`.",
          "type": "string"
        },
        "window": {
          "description": "Time window for the burn rate calculation.",
          "type": "string"
        }
      },
      "required": [
        "window"
      ],
      "type": "object"
    },
    "DefinitionTimeWindow": {
      "properties": {
        "duration": {
          "description": "Time window that defines the evaluation period as a string, in the format\nlike `\"28d\"` (28 days) or `\"24h\"` (24 hours).",
          "example": "\"30d\"",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DerivedLabelMetricLabel": {
      "properties": {
        "constructed_label": {
          "allOf": [
            {
              "$ref": "#/definitions/MetricLabelConstructedLabel"
            }
          ],
          "description": "A constructed label creates a label where none previously existed, in contrast\nto a mapping derived label. For example, this mapping constructs a label\nthat's defined only when an `instance` begins with\n`m3coordinator-{read,write,admin}`, and where the value is statically\ndefined.\n```yaml\nlabel_name: tier\nconstructed_label:\n  value_definitions:\n     - filters:\n        - name: instance\n          value_glob: m3coordinator-read*\n       value: read\n     - filters:\n        - name: instance\n          value_glob: m3coordinator-write*\n       value: write\n     - filters:\n        - name: instance\n          value_glob: m3coordinator-admin*\n       value: admin\n```"
        },
        "mapping_label": {
          "allOf": [
            {
              "$ref": "#/definitions/MetricLabelMappingLabel"
            }
          ],
          "description": "A mapping label is a type of derived label that's generated by pulling values\nfrom some other label on the time series. For example, this mapping matches a\nlabel that's defined only when `__name__` begins with `envoy_` or `grpc_,` and\nwhere the value is copied from `backend_service` or `grpc_service`:\n```yaml\nlabel_name: chronosphere_service\nmapping_label:\n  name_mappings:\n     - filters:\n        - name: __name__\n          value_glob: grpc_*\n       source_label: grpc_service\n     - filters:\n        - name: __name__\n          value_glob: envoy_*\n       source_label: backend_service\n```"
        }
      },
      "type": "object"
    },
    "DerivedLabelSpanTag": {
      "properties": {
        "name_mappings": {
          "description": "Determines where the input data for a derived label comes from. For each\nname mapping, you must define a `source_label`. If multiple name mappings\nare defined, the first name mapping that matches is used to map the source\ntag to the derived tag.",
          "items": {
            "$ref": "#/definitions/DerivedLabelSpanTagNameMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedLabelSpanTagNameMapping": {
      "properties": {
        "source_tag": {
          "description": "The source span tag name.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DerivedMetricQuery": {
      "properties": {
        "prometheus_expr": {
          "description": "PromQL expression the derived metric executes. The expression should\ninclude all configured variables.",
          "example": "cpu_usage{$service, $instance} / sum(cpu_usage{$service})",
          "type": "string"
        },
        "variables": {
          "description": "Optional. Specifies the variables that can be used in the derived metric as\nlabel selectors.",
          "items": {
            "$ref": "#/definitions/DerivedMetricVariable"
          },
          "type": "array"
        }
      },
      "required": [
        "prometheus_expr"
      ],
      "type": "object"
    },
    "DerivedMetricSelector": {
      "properties": {
        "labels": {
          "description": "Labels that must match in the derived metric usage for the selector to match.",
          "items": {
            "$ref": "#/definitions/configv1DerivedMetricLabelMatcher"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DerivedMetricSelectorQuery": {
      "properties": {
        "query": {
          "allOf": [
            {
              "$ref": "#/definitions/DerivedMetricQuery"
            }
          ],
          "description": "The query to run when the selector matches."
        },
        "selector": {
          "allOf": [
            {
              "$ref": "#/definitions/DerivedMetricSelector"
            }
          ],
          "description": "Optional. Defines the selection criteria to select which query to use for the\ngiven derived metric. If selector is empty, then the corresponding query is\nthe default query used for the derived metric. Exactly one default query must\nbe configured."
        }
      },
      "required": [
        "query"
      ],
      "type": "object"
    },
    "DerivedMetricVariable": {
      "properties": {
        "default_prometheus_selector": {
          "description": "PromQL label selector, which must match the given variable name. If the\nvariable is not specified in the derived metric usage, then the default\nselector is used.",
          "example": "service=~\".*\"",
          "type": "string"
        },
        "name": {
          "description": "Name of the variable.",
          "example": "service",
          "type": "string"
        }
      },
      "required": [
        "default_prometheus_selector",
        "name"
      ],
      "type": "object"
    },
    "DropRuleConditionalRateBasedDrop": {
      "description": "No longer supported and cannot be used.\nDefines behavior for conditional drop policies.",
      "properties": {
        "activated_drop_duration_secs": {
          "description": "Once activated, activated_drop_duration_secs defines how long the drop\nrule stays activated before rechecking against the rate_limit_threshold.",
          "format": "int32",
          "type": "integer"
        },
        "enabled": {
          "description": "Enables rate-based metric dropping.",
          "type": "boolean"
        },
        "rate_limit_threshold": {
          "description": "Percentage of the licensed limit reached in order to activate the drop\nrule, between 0 and 100.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "DropRuleValueBasedDrop": {
      "properties": {
        "enabled": {
          "description": "Enables dropping metrics based on a set value.",
          "type": "boolean"
        },
        "target_drop_value": {
          "description": "The target data point value at which to drop metrics.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "EmitMetricsCounter": {
      "properties": {
        "value": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogFieldPath"
            }
          ],
          "description": "Optional. Specifies the name of the log field whose value you want to use as\nthe metric value. If unset, the counter increments by one."
        }
      },
      "type": "object"
    },
    "EmitMetricsGauge": {
      "properties": {
        "aggregation_type": {
          "allOf": [
            {
              "$ref": "#/definitions/GaugeAggregationType"
            }
          ],
          "description": "The aggregation type to use for the gauge. Must be one of the following\nvalues:"
        },
        "value": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogFieldPath"
            }
          ],
          "description": "The name of the log field whose value you want to use as the metric value."
        }
      },
      "required": [
        "value"
      ],
      "type": "object"
    },
    "EmitMetricsHistogram": {
      "properties": {
        "value": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogFieldPath"
            }
          ],
          "description": "The name of the log field whose value you want to use as the metric value."
        }
      },
      "required": [
        "value"
      ],
      "type": "object"
    },
    "EmitMetricsMetricMode": {
      "enum": [
        "COUNTER",
        "GAUGE",
        "HISTOGRAM"
      ],
      "type": "string"
    },
    "FilterOperator": {
      "enum": [
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "GaugeAggregationType": {
      "enum": [
        "LAST",
        "MIN",
        "MAX"
      ],
      "type": "string"
    },
    "GcpMetricsIntegrationMetricGroup": {
      "properties": {
        "prefixes": {
          "description": "A list of Google Cloud metric prefixes to ingest.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "project_id": {
          "description": "The Google Cloud project ID that can access the metric data.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GraphiteLabelPolicyReplace": {
      "properties": {
        "name": {
          "description": "Name of the label to replace the value for. Only positional Graphite labels\nsuch as `__gX__` are allowed.",
          "example": "__g1__",
          "type": "string"
        },
        "new_value": {
          "description": "New value of the replaced label.",
          "example": "ALL_HOSTS",
          "type": "string"
        }
      },
      "required": [
        "name",
        "new_value"
      ],
      "type": "object"
    },
    "GroupByGroupByKey": {
      "description": "GroupByKey describes a key to group by.",
      "properties": {
        "named_key": {
          "description": "For named key types, such as span tags, indicates the name of the key to\ngroup by.",
          "type": "string"
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/GroupByKeyGroupByKeyType"
            }
          ],
          "description": "Type of key to group by."
        }
      },
      "type": "object"
    },
    "GroupByKeyGroupByKeyType": {
      "description": " - SERVICE: The service to group by.\n - OPERATION: The operation to group by.\n - TAG: The span tag to group by.",
      "enum": [
        "SERVICE",
        "OPERATION",
        "TAG"
      ],
      "type": "string"
    },
    "HTTPConfigBasicAuth": {
      "properties": {
        "password": {
          "type": "string"
        },
        "username": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "HTTPConfigTLSConfig": {
      "properties": {
        "insecure_skip_verify": {
          "description": "If `true`, disables validation of the server certificate.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ListMutingRulesRequestState": {
      "enum": [
        "PENDING",
        "ACTIVE",
        "EXPIRED"
      ],
      "type": "string"
    },
    "LogAllocationConfigDatasetAllocation": {
      "properties": {
        "allocation": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
            }
          ],
          "description": "Specifies the percentage of the budget to allocate to this dataset."
        },
        "dataset_slug": {
          "description": "Slug of the dataset.",
          "type": "string"
        },
        "priorities": {
          "allOf": [
            {
              "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
            }
          ],
          "description": "Defines explicit high and low priority match criteria to specify which logs to\ndrop first (low) and last (high). Anything not matched by either set of rules\nis considered default priority and is dropped after low priority but before\nhigh priority data."
        }
      },
      "type": "object"
    },
    "LogAllocationConfigDefaultDataset": {
      "description": "Configuration for default dataset.",
      "properties": {
        "allocation": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogAllocationConfigAllocation"
            }
          ],
          "description": "Sets the percentage of the license limit to allocate to this dataset."
        },
        "priorities": {
          "allOf": [
            {
              "$ref": "#/definitions/LogAllocationConfigHighLowPriorities"
            }
          ],
          "description": "Defines explicit high and low priority match criteria to specify which logs to\ndrop first (low) and last (high). Anything not matched by either set of rules\nis considered default priority and is dropped after low priority but before\nhigh priority data."
        }
      },
      "type": "object"
    },
    "LogAllocationConfigHighLowPriorities": {
      "description": "Defines explicit high and low priority match criteria to specify which logs to\ndrop first (low) and last (high). Anything not matched by either set of rules is\nconsidered default priority and is dropped after low priority but before high\npriority data.",
      "properties": {
        "high_priority_filters": {
          "description": "A list of search filters defining which logs are considered high priority in\nthis dataset. Filters are combined as OR statements so only one filter needs\nto match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "A list of search filters defining which logs are considered low priority in\nthis dataset. Filters are combined as OR statements so only one filter needs\nto match.",
          "items": {
            "$ref": "#/definitions/configv1LogSearchFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogControlRuleDropField": {
      "description": "DropField is the configuration for a drop field action.",
      "properties": {
        "field_regex": {
          "description": "Defines the the regular expression that determines which fields to drop.",
          "type": "string"
        },
        "parent_path": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogFieldPath"
            }
          ],
          "description": "Optional. Specifies the level of depth in the log to apply the regular\nexpression to. For example, if you want to apply the regular expression to\nfields under `httpRequest`, such as `httpRequest.status`, enter `httpRequest`\nin the `parent_path` field. If empty, the fields to drop are at the root level\nof the log."
        }
      },
      "required": [
        "field_regex"
      ],
      "type": "object"
    },
    "LogControlRuleEmitMetrics": {
      "description": "EmitMetrics is the configuration for emit metrics action.",
      "properties": {
        "counter": {
          "allOf": [
            {
              "$ref": "#/definitions/EmitMetricsCounter"
            }
          ],
          "description": "Generates a metric that counts the number of times a certain event has\noccurred."
        },
        "drop_log": {
          "description": "Optional. If `true`, drops the entire log after emitting the defined metric.",
          "type": "boolean"
        },
        "gauge": {
          "allOf": [
            {
              "$ref": "#/definitions/EmitMetricsGauge"
            }
          ],
          "description": "Generates a metric that tracks a value, which changes over time. Choose `LAST`\n(most recent), `MIN` (minimum value), or `MAX` (maximum value) to define which\nvalue to use."
        },
        "histogram": {
          "allOf": [
            {
              "$ref": "#/definitions/EmitMetricsHistogram"
            }
          ],
          "description": "Generates a metric that tracks the distribution of values across data\ngroupings with exponentially increasing size."
        },
        "labels": {
          "description": "The labels to emit with the metric, specified as key/value pairs. The\ngenerated label is a valid Prometheus label name, mapped to a log key.",
          "items": {
            "$ref": "#/definitions/LogControlRuleEmitMetricsLabel"
          },
          "type": "array"
        },
        "mode": {
          "allOf": [
            {
              "$ref": "#/definitions/EmitMetricsMetricMode"
            }
          ],
          "description": "Indicates the mode of the generated metric. Must be one of the following\nvalues:"
        },
        "name": {
          "description": "A unique name for the generated metric. This name must conform to Prometheus\nnaming conventions.",
          "type": "string"
        }
      },
      "required": [
        "mode",
        "name"
      ],
      "type": "object"
    },
    "LogControlRuleEmitMetricsLabel": {
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "$ref": "#/definitions/configv1LogFieldPath"
        }
      },
      "type": "object"
    },
    "LogControlRuleReplaceField": {
      "description": "ReplaceField is the configuration for a replace field action.",
      "properties": {
        "field": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogFieldPath"
            }
          ],
          "description": "Specifies the field inside the log data to apply the rule to."
        },
        "mapped_value": {
          "allOf": [
            {
              "$ref": "#/definitions/ReplaceFieldMappedValue"
            }
          ],
          "description": "Defines the configuration for the mapped value replacement mode."
        },
        "replace_all": {
          "description": "Determines whether to replace all matches or just the first match.",
          "type": "boolean"
        },
        "replace_mode": {
          "allOf": [
            {
              "$ref": "#/definitions/ReplaceFieldReplaceMode"
            }
          ],
          "description": "Defines the replacement mode to use in the replace rule. Must be one of the\nfollowing values:"
        },
        "replace_regex": {
          "description": "Defines the the regular expression that determines which part of the field to\nreplace.",
          "type": "string"
        },
        "static_value": {
          "allOf": [
            {
              "$ref": "#/definitions/ReplaceFieldStaticValue"
            }
          ],
          "description": "Defines the configuration for the fixed value replacement mode."
        }
      },
      "required": [
        "field",
        "replace_mode",
        "replace_regex"
      ],
      "type": "object"
    },
    "LogControlRuleSample": {
      "description": "Sample is the configuration for the sample logs action.",
      "properties": {
        "rate": {
          "description": "Percentage of matching logs to keep. Must be in the range `[0, 1]`, where `1`\nis equal to 100% of logs. For example, to keep 25% of logs, enter `0.25` as\nthe `rate`.",
          "format": "double",
          "type": "number"
        }
      },
      "required": [
        "rate"
      ],
      "type": "object"
    },
    "LogIngestConfigFieldNormalization": {
      "description": "FieldNormalization allows you to map and normalize well-known fields from your logs.\nThese mappings run after parsing to standardize common fields like timestamp,\nseverity level, primary key name, and message across different log formats.",
      "properties": {
        "custom_field_normalization": {
          "description": "Maps additional custom fields from your logs. These will not be indexed.\nUse these for any other fields you want to normalize, such as environment, region, or user ID.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigNamedStringNormalization"
          },
          "type": "array"
        },
        "message": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigStringNormalization"
            }
          ],
          "description": "Maps the main message field from your logs.\nThis is typically the human-readable description of the log event."
        },
        "primary_key": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigNamedStringNormalization"
            }
          ],
          "description": "Maps the primary identifier field from your logs (e.g., service name, application name).\nThe mapped value will be indexed and can be used for filtering and grouping. Currently this is limitied to \"service\" field."
        },
        "severity": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigStringNormalization"
            }
          ],
          "description": "Maps severity or log level fields (e.g., ERROR, WARN, INFO, DEBUG).\nUse value mapping to normalize different severity formats across your logs."
        },
        "timestamp": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigTimestampNormalization"
            }
          ],
          "description": "Maps timestamp fields from your logs to ensure consistent time ordering.\nThe system will try each specified field in order until a valid timestamp is found."
        }
      },
      "type": "object"
    },
    "LogIngestConfigLogFieldParser": {
      "properties": {
        "destination": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogFieldPath"
            }
          ],
          "description": "The destination field for storing parsed structured data.\nIf the specified key already exists, its value is overwritten.\nIf this value is unset, the log is updated at the root level and any\nconflicting keys are overwritten."
        },
        "mode": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigLogFieldParserMode"
            }
          ],
          "description": "Specifies whether the field parser is enabled or disabled."
        },
        "parser": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigLogParser"
            }
          ],
          "description": "The parser to apply to the source field."
        },
        "source": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogFieldPath"
            }
          ],
          "description": "The source field to parse."
        }
      },
      "type": "object"
    },
    "LogIngestConfigLogFieldParserMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "LogIngestConfigLogParser": {
      "properties": {
        "key_value_parser": {
          "$ref": "#/definitions/LogParserKeyValueParser"
        },
        "parser_type": {
          "allOf": [
            {
              "$ref": "#/definitions/LogParserParserType"
            }
          ],
          "description": "The type of parser to use."
        },
        "regex_parser": {
          "allOf": [
            {
              "$ref": "#/definitions/LogParserRegexParser"
            }
          ],
          "description": "This object contains settings relevant to `REGEX` parsers."
        }
      },
      "type": "object"
    },
    "LogIngestConfigNamedStringNormalization": {
      "description": "NamedStringNormalization maps a field to a named target with optional transformations.",
      "properties": {
        "normalization": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigStringNormalization"
            }
          ],
          "description": "The normalization configuration for this field."
        },
        "target": {
          "description": "The name of the target field where the normalized value will be stored.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogIngestConfigPlaintextParser": {
      "properties": {
        "keep_original": {
          "description": "If `true`, the original log is retained after parsing and stored in the\nkey `plaintext_log`. If `false`, the original log is dropped after parsing.\nDefault value: `false`.",
          "type": "boolean"
        },
        "mode": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigPlaintextParserMode"
            }
          ],
          "description": "Specifies whether the parser is enabled or disabled."
        },
        "name": {
          "description": "The name of the parser. Must be unique within the configuration.",
          "type": "string"
        },
        "parser": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigLogParser"
            }
          ],
          "description": "The parser configuration to apply to plaintext logs."
        }
      },
      "type": "object"
    },
    "LogIngestConfigPlaintextParserMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "LogIngestConfigStringNormalization": {
      "description": "StringNormalization defines how to extract and transform string values from log fields.",
      "properties": {
        "default_value": {
          "description": "Default value to use when no source fields contain values.",
          "type": "string"
        },
        "sanitize_patterns": {
          "description": "Optional regex patterns to extract and sanitize values.\nEach pattern must have exactly one capturing group that will be used as the result.\nFor example: \"^.*level=([A-Z]+).*$\" to extract log level from a string.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "source": {
          "description": "List of field paths to check for values, in priority order.\nThe first non-empty value found will be used.",
          "items": {
            "$ref": "#/definitions/configv1LogFieldPath"
          },
          "type": "array"
        },
        "value_map": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional mapping to normalize values.\nFor example: {\"warn\": \"WARNING\", \"err\": \"ERROR\"} to standardize severity levels.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "LogIngestConfigTimestampNormalization": {
      "description": "TimestampNormalization specifies which fields to check for timestamp values.",
      "properties": {
        "source": {
          "description": "List of field paths to check for timestamp values, in priority order.\nCommon fields include \"timestamp\", \"@timestamp\", \"time\", \"datetime\".",
          "items": {
            "$ref": "#/definitions/configv1LogFieldPath"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "LogParserKeyValueParser": {
      "description": "A parser to extract key/value pairs from a string.\nIf duplicate keys are found, the first instance is used.",
      "properties": {
        "delimiter": {
          "description": "The string for splitting the input into key/value pairs.",
          "type": "string"
        },
        "pair_separator": {
          "description": "The string for splitting each pair into its key and value.",
          "type": "string"
        },
        "trim_set": {
          "description": "Specifies the code points of any Unicode characters to trim from the\nbeginning and end of keys and values.",
          "type": "string"
        }
      },
      "required": [
        "delimiter",
        "pair_separator"
      ],
      "type": "object"
    },
    "LogParserParserType": {
      "enum": [
        "JSON",
        "REGEX",
        "KEY_VALUE"
      ],
      "type": "string"
    },
    "LogParserRegexParser": {
      "properties": {
        "regex": {
          "description": "The regular expression parser pattern to apply. Must use RE2 syntax.\nNamed capturing groups become named fields in the extracted log.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionActionType": {
      "enum": [
        "EMAIL",
        "HUMIO_REPO",
        "OPS_GENIE",
        "PAGER_DUTY",
        "SLACK",
        "SLACK_POST_MESSAGE",
        "VICTOR_OPS",
        "WEBHOOK",
        "UPLOAD_FILE"
      ],
      "type": "string"
    },
    "LogScaleActionEmailAction": {
      "properties": {
        "attach_csv": {
          "description": "Whether the result set should be attached as a CSV file.",
          "type": "boolean"
        },
        "body_template": {
          "description": "Body of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "recipients": {
          "description": "List of email addresses to send an email to.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "subject_template": {
          "description": "Subject of the email. Can be templated with values from the query result.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionHumioRepoAction": {
      "properties": {
        "ingest_token": {
          "description": "Ingest token for the repository that the action should ingest into.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionOpsGenieAction": {
      "properties": {
        "api_url": {
          "description": "OpsGenie webhook URL to send the request to.",
          "type": "string"
        },
        "ops_genie_key": {
          "description": "Key to authenticate with OpsGenie.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionPagerDutyAction": {
      "properties": {
        "routing_key": {
          "description": "Routing key to authenticate with PagerDuty.",
          "type": "string"
        },
        "severity": {
          "allOf": [
            {
              "$ref": "#/definitions/PagerDutyActionSeverity"
            }
          ],
          "description": "Severity level of the message."
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackAction": {
      "properties": {
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "url": {
          "description": "Slack webhook URL to send the request to.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionSlackPostMessageAction": {
      "properties": {
        "api_token": {
          "description": "API token to authenticate with Slack.",
          "type": "string"
        },
        "channels": {
          "description": "List of Slack channels to message.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "fields": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Fields to include within the Slack message. Can be templated with values from the query result.",
          "type": "object"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionUploadFileAction": {
      "properties": {
        "file_name": {
          "description": "File name for the uploaded file.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "LogScaleActionVictorOpsAction": {
      "properties": {
        "message_type": {
          "description": "Type of the VictorOps message to make.",
          "type": "string"
        },
        "notify_url": {
          "description": "VictorOps webhook URL to send the request to.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleActionWebhookAction": {
      "properties": {
        "body_template": {
          "description": "Body of the HTTP or HTTPS request. Can be templated with values from the query result.",
          "type": "string"
        },
        "headers": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Headers of the HTTP or HTTPS request.",
          "type": "object"
        },
        "ignore_ssl": {
          "description": "Flag indicating whether SSL should be ignored for the request.",
          "type": "boolean"
        },
        "method": {
          "allOf": [
            {
              "$ref": "#/definitions/WebhookActionHTTPMethod"
            }
          ],
          "description": "HTTP method to use for the request."
        },
        "url": {
          "description": "URL to send the HTTP or HTTPS request to.",
          "type": "string"
        },
        "use_proxy": {
          "description": "Defines whether the action should use the configured proxy to make web requests.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LogScaleAlertAlertType": {
      "enum": [
        "STANDARD",
        "FILTER"
      ],
      "type": "string"
    },
    "MappedValueReplacePair": {
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "MappingLabelValueMapping": {
      "properties": {
        "source_value_globs": {
          "description": "Defines the source label values that map into the given `target_value`.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "target_value": {
          "description": "The value that `source_value_globs` are mapped into. For example, this\nmapping indicates that the target value `cat` maps to the source label's\nvalues of `Cat` and `CAT`.:\n```yaml\nvalue_mappings:\n - source_value_globs:\n     - Cat\n     - CAT\n   target_value: cat\n```",
          "type": "string"
        }
      },
      "type": "object"
    },
    "MappingRuleAggregationPolicy": {
      "properties": {
        "aggregation": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1AggregationType"
            }
          ],
          "description": "Defines the method by which metrics are aggregated."
        },
        "drop_timestamp": {
          "description": "Deprecated: This parameter is no longer supported.",
          "type": "boolean"
        },
        "interval": {
          "description": "The interval between aggregated data points.",
          "type": "string"
        },
        "storage_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1MappingRuleStoragePolicy"
            }
          ],
          "description": "Deprecated: Use `interval` instead."
        }
      },
      "type": "object"
    },
    "MetricLabelConstructedLabel": {
      "properties": {
        "value_definitions": {
          "items": {
            "$ref": "#/definitions/ConstructedLabelValueDefinition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricLabelMappingLabel": {
      "properties": {
        "name_mappings": {
          "description": "Determines where the input data for a derived label comes from. For each\nname mapping, you must define a `source_label`. If multiple name mappings\nare defined, the first name mapping that matches is used to map the source\nlabel to the derived label.",
          "items": {
            "$ref": "#/definitions/MetricLabelMappingLabelNameMapping"
          },
          "type": "array"
        },
        "value_mappings": {
          "description": "These value mappings apply to the whole mapping label.\nIf there's no name_mappings, these value mappings apply to the label that exists on the metric.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "required": [
        "name_mappings"
      ],
      "type": "object"
    },
    "MetricLabelMappingLabelNameMapping": {
      "properties": {
        "filters": {
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "source_label": {
          "description": "The source label name on the time series from when it was ingested.",
          "type": "string"
        },
        "value_mappings": {
          "description": "These value mappings apply only to the name mapping they belong to.",
          "items": {
            "$ref": "#/definitions/MappingLabelValueMapping"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MetricsRestrictionPermission": {
      "enum": [
        "READ",
        "WRITE",
        "READ_WRITE"
      ],
      "type": "string"
    },
    "MonitorSchedule": {
      "properties": {
        "timezone": {
          "description": "The timezone of the time ranges.",
          "type": "string"
        },
        "weekly_schedule": {
          "allOf": [
            {
              "$ref": "#/definitions/ScheduleWeeklySchedule"
            }
          ],
          "description": "Specifies the monitor schedule for each day of the week. You must include\nevery day of the week. Specify `active: NEVER` for days when you don't want\nthe monitor to be active."
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditions": {
      "description": "Conditions evaluated against each queried series to determine the severity of each series.",
      "properties": {
        "defaults": {
          "allOf": [
            {
              "$ref": "#/definitions/SeriesConditionsSeverityConditions"
            }
          ],
          "description": "Mapping of alert severity to its conditions. All conditions are\nevaluated for every series. If multiple conditions match, the highest\nseverity is chosen."
        },
        "overrides": {
          "description": "Optional. Specifies a list of overrides to use for series having matching\nlabels. Each override defines labels that potentially match a series' labels.\nIf one or more overrides match a series, the severity conditions of the first\nmatching override are used instead of the defaults.\n\nCannot be used if `graphite_query` is set.",
          "items": {
            "$ref": "#/definitions/MonitorSeriesConditionsOverride"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "MonitorSeriesConditionsOverride": {
      "properties": {
        "label_matchers": {
          "description": "Set of matchers on a series' labels. If all labels match, then the conditions\ndefined in this override are used.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "severity_conditions": {
          "allOf": [
            {
              "$ref": "#/definitions/SeriesConditionsSeverityConditions"
            }
          ],
          "description": "Mapping of alert severity to its conditions for series that match this\noverride. These conditions supersede the default conditions, and are not\nmerged with the default conditions."
        }
      },
      "type": "object"
    },
    "MonitorSignalGrouping": {
      "description": "SignalGrouping defines how the set of series from the query are split into signals.",
      "properties": {
        "label_names": {
          "description": "Set of label names used to split series into signals. Each unique combination\nof labels result in its own signal. For example, if `label_names` is\n`[\"service\", \"code\"]`, then all series including labels\n`{service=\"foo\",code=\"404\"}` will be grouped together in the same signal.\n\nCannot be used if `graphite_query` is set.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "signal_per_series": {
          "description": "If set to `true`, each series will have its own signal. Cannot be used with\n`label_names`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutes": {
      "properties": {
        "defaults": {
          "allOf": [
            {
              "$ref": "#/definitions/RoutesSeverityNotifiers"
            }
          ],
          "description": "The default notifiers to use if no override is found."
        },
        "overrides": {
          "description": "A list of overrides to use for alert notification policies. Each\noverride defines the labels that potentially match an alert. If an alert has\nmatching labels, the override notification policy is used for that alert\ninstead of the default notification policy. If multiple overrides match\nthe same alert, the first matching override notification policy is used.",
          "items": {
            "$ref": "#/definitions/NotificationPolicyRoutesOverride"
          },
          "type": "array"
        }
      },
      "required": [
        "defaults"
      ],
      "type": "object"
    },
    "NotificationPolicyRoutesGroupBy": {
      "properties": {
        "label_names": {
          "description": "Set of label names used to group alerts.\nFor example, if label_names is [\"service\", \"code\"] then all alerts including labels {service=\"foo\",code=\"404\"}\nwill be grouped together.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "NotificationPolicyRoutesOverride": {
      "properties": {
        "alert_label_matchers": {
          "description": "The alert labels to match against. If an alert matches all of these labels,\nthe override notifier is applied to that alert.",
          "items": {
            "$ref": "#/definitions/configv1LabelMatcher"
          },
          "type": "array"
        },
        "notifiers": {
          "allOf": [
            {
              "$ref": "#/definitions/RoutesSeverityNotifiers"
            }
          ],
          "description": "The notifiers that will receive the alerts matched by overrides."
        }
      },
      "type": "object"
    },
    "NotifierEmailConfig": {
      "properties": {
        "html": {
          "description": "The body of the email to send, in HTML format.",
          "type": "string"
        },
        "text": {
          "description": "The body of the email to send, in plain text format.",
          "type": "string"
        },
        "to": {
          "description": "The email address to send notifications to. Required if including an\n`email` object in your request body.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierHTTPConfig": {
      "properties": {
        "basic_auth": {
          "allOf": [
            {
              "$ref": "#/definitions/HTTPConfigBasicAuth"
            }
          ],
          "description": "If an object is specified, sets an `Authorization` header with the\nvalues of `password` and `username`. Cannot be set if `bearer_token` is\nset."
        },
        "bearer_token": {
          "description": "Sets a token for bearer authentication. Cannot be set if `basic_auth` is set.",
          "type": "string"
        },
        "proxy_url": {
          "description": "Your proxy URL. (This parameter is deprecated, and custom proxies are\nunsupported.)",
          "type": "string"
        },
        "tls_config": {
          "allOf": [
            {
              "$ref": "#/definitions/HTTPConfigTLSConfig"
            }
          ],
          "description": "Your TLS configuration."
        }
      },
      "type": "object"
    },
    "NotifierOpsGenieConfig": {
      "properties": {
        "api_key": {
          "description": "Your Opsgenie API key. Required if including an `ops_genie` object in your\nrequest body.",
          "type": "string"
        },
        "api_url": {
          "description": "The Opsgenie API URL to send requests to. Required if including an\n`ops_genie` object in your request body.",
          "example": "https://api.opsgenie.com/",
          "type": "string"
        },
        "description": {
          "description": "A description of the alert.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of key/value pairs with additional information about the alert. These\nkey/value pairs can include any arbitrary data.",
          "type": "object"
        },
        "http_config": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierHTTPConfig"
            }
          ],
          "description": "Your HTTP client configuration."
        },
        "message": {
          "description": "The alert text.",
          "type": "string"
        },
        "note": {
          "description": "A note about the alert.",
          "type": "string"
        },
        "priority": {
          "description": "The priority level of alert. Possible values are `P1`, `P2`, `P3`, `P4`, and `P5`.",
          "type": "string"
        },
        "responders": {
          "description": "List of responders responsible for notifications.",
          "items": {
            "$ref": "#/definitions/OpsGenieConfigResponder"
          },
          "type": "array"
        },
        "source": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "tags": {
          "description": "A comma-separated list of tags attached to the notifications.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierPagerdutyConfig": {
      "properties": {
        "class": {
          "description": "The class of the event.",
          "type": "string"
        },
        "client": {
          "description": "The client identification of the notification sender.",
          "type": "string"
        },
        "client_url": {
          "description": "A backlink to the sender of the notification.",
          "type": "string"
        },
        "component": {
          "description": "The part or component of the affected system that is broken.",
          "type": "string"
        },
        "description": {
          "description": "A description of the incident.",
          "type": "string"
        },
        "details": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A set of key/value pairs with additional information about the incident. These\nkey/value pairs can include any arbitrary data.",
          "type": "object"
        },
        "group": {
          "description": "A cluster or grouping of services.",
          "type": "string"
        },
        "http_config": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierHTTPConfig"
            }
          ],
          "description": "Your HTTP client configuration."
        },
        "images": {
          "description": "Images to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigImage"
          },
          "type": "array"
        },
        "links": {
          "description": "Links to attach to the incident.",
          "items": {
            "$ref": "#/definitions/PagerdutyConfigLink"
          },
          "type": "array"
        },
        "routing_key": {
          "description": "Your PagerDuty integration key, if using the PagerDuty integration type\n`Events API v2`. Cannot be set if `service_key` is set.",
          "type": "string"
        },
        "service_key": {
          "description": "Your PagerDuty integration key, if using the PagerDuty integration type\n`Prometheus`. Cannot be set if `routing_key` is set.",
          "type": "string"
        },
        "severity": {
          "description": "The severity of the incident. Possible values: `critical`, `error`,\n`warning`, or `info`.",
          "type": "string"
        },
        "url": {
          "description": "The Pagerduty URL to send API requests to.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfig": {
      "properties": {
        "actions": {
          "items": {
            "$ref": "#/definitions/NotifierSlackConfigAction"
          },
          "type": "array"
        },
        "api_url": {
          "description": "Your Slack webhook API URL. Required if including a `slack` object in\nyour request body.",
          "type": "string"
        },
        "callback_id": {
          "type": "string"
        },
        "channel": {
          "description": "The channel to send notifications to.",
          "type": "string"
        },
        "color": {
          "type": "string"
        },
        "fallback": {
          "type": "string"
        },
        "fields": {
          "items": {
            "$ref": "#/definitions/SlackConfigField"
          },
          "type": "array"
        },
        "footer": {
          "type": "string"
        },
        "http_config": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierHTTPConfig"
            }
          ],
          "description": "Your HTTP client configuration."
        },
        "icon_emoji": {
          "type": "string"
        },
        "icon_url": {
          "type": "string"
        },
        "image_url": {
          "type": "string"
        },
        "link_names": {
          "type": "boolean"
        },
        "mrkdwn_in": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "pretext": {
          "type": "string"
        },
        "short_fields": {
          "type": "boolean"
        },
        "text": {
          "type": "string"
        },
        "thumb_url": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "title_link": {
          "type": "string"
        },
        "username": {
          "description": "The user to send notifications to.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierSlackConfigAction": {
      "properties": {
        "confirm_field": {
          "$ref": "#/definitions/SlackConfigConfirmationField"
        },
        "name": {
          "type": "string"
        },
        "style": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierVictorOpsConfig": {
      "properties": {
        "api_key": {
          "description": "Your VictorOps API key. Required if including a `victor_ops` object in\nyour request body.",
          "type": "string"
        },
        "api_url": {
          "description": "The VictorOps API URL. Required if including a `victor_ops` object in your\nrequest body.",
          "type": "string"
        },
        "custom_fields": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        "entity_display_name": {
          "description": "A summary of the alerted problem.",
          "type": "string"
        },
        "http_config": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierHTTPConfig"
            }
          ],
          "description": "Your HTTP client configuration."
        },
        "message_type": {
          "description": "The behavior of the alert. Possible values are `CRITICAL`, `WARNING`, and\n`INFO`.",
          "type": "string"
        },
        "monitoring_tool": {
          "description": "The monitoring tool from which the state message originated.",
          "type": "string"
        },
        "routing_key": {
          "description": "Your VictorOps routing key. Required if including a `victor_ops` object in\nyour request body.",
          "type": "string"
        },
        "state_message": {
          "description": "A detailed explanation of the alerted problem.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NotifierWebhookConfig": {
      "properties": {
        "http_config": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierHTTPConfig"
            }
          ],
          "description": "Your HTTP client configuration."
        },
        "url": {
          "description": "Your webhook URL. This URL will be called as a `POST` request. Required\nif including a `webhook` object in your request body.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NumericFilterComparisonType": {
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL"
      ],
      "type": "string"
    },
    "OpsGenieConfigResponder": {
      "properties": {
        "id": {
          "description": "The ID of the responder. Cannot be set if `name` or `username` are set.",
          "type": "string"
        },
        "name": {
          "description": "The name of the responder. Cannot be set if `id` or `username` are set.",
          "type": "string"
        },
        "responder_type": {
          "allOf": [
            {
              "$ref": "#/definitions/ResponderResponderType"
            }
          ],
          "description": "The type of the responder."
        },
        "username": {
          "description": "The username of the responder. Cannot be set if `id` or `name` are set.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "OtelMetricsIngestionResourceAttributes": {
      "properties": {
        "exclude_keys": {
          "description": "Specifies resource attributes to exclude. If a resource attribute's key\nmatches any of the strings in this array, that resource attribute is\nexcluded.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "filter_mode": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourceAttributesFilterMode"
            }
          ],
          "description": "Specifies which filter mode to use for copying resource attributes into\nthe label set. The `APPEND_DEFAULT_EXCLUDE_KEYS` mode copies all resource\nattributes, excluding any that match either the user-supplied\n`exclude_keys` list or a Chronosphere-managed list of suggested\nexclusions. The `CUSTOM_EXCLUDE_KEYS` mode copies all resource\nattributes, excluding any that match the user-supplied `exclude_keys`\nlist, but is not affected by the Chronosphere-managed list of exclusions.\nDefault: `APPEND_DEFAULT_EXCLUDE_KEYS`."
        },
        "flatten_mode": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourceAttributesFlattenMode"
            }
          ],
          "description": "Specifies how to combine hierarchical OpenTelemetry attributes into a\nsingle set of of labels for a given time series. The `MERGE` mode copies\nresource attributes only if there is no conflicting attribute on the\nindividual data point. The `OVERWRITE` mode gives resource attributes\nprecedence over data point attributes. The `IGNORE` mode doesn't copy any\nresource attributes into the time series label set. Default: `MERGE`."
        },
        "generate_target_info": {
          "description": "If `true`, generates a `target_info` time series with labels derived from\nresource attributes. The `filter_mode` and `exclude_keys` settings apply\nin the same manner that they apply to the `flatten` operation. Default:\n`false`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PagerDutyActionSeverity": {
      "enum": [
        "CRITICAL",
        "ERROR",
        "WARNING",
        "INFO"
      ],
      "type": "string"
    },
    "PagerdutyConfigImage": {
      "properties": {
        "alt": {
          "type": "string"
        },
        "href": {
          "type": "string"
        },
        "src": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PagerdutyConfigLink": {
      "properties": {
        "href": {
          "type": "string"
        },
        "text": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PartitionFilterCondition": {
      "properties": {
        "dataset_slug": {
          "description": "If set, matches incoming data that belongs to the specified dataset.\nThe dataset type must match the budget resource. For example,\n`resource=LOG_PERSISTED_BYTES`, then the dataset type must be\n`type=LOGS`.\n\nExactly one of `dataset_slug` or `log_filter` must be set.",
          "type": "string"
        },
        "log_filter": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogSearchFilter"
            }
          ],
          "description": "If set, matches incoming log data by log query.\n\nExactly one of `dataset_slug` or `log_filter` must be set."
        }
      },
      "type": "object"
    },
    "PerOperationSamplingStrategiesPerOperationSamplingStrategy": {
      "properties": {
        "operation": {
          "description": "The operation to which this specific strategy applies.",
          "type": "string"
        },
        "probabilistic_sampling_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
            }
          ],
          "description": "Defines the probabilistic strategy to apply to traces matching this\noperation."
        }
      },
      "type": "object"
    },
    "ReplaceFieldMappedValue": {
      "description": "MappedValue is the configuration for mapped value replace mode.",
      "properties": {
        "default_value": {
          "description": "The value to use if no matching value is found.",
          "type": "string"
        },
        "pairs": {
          "description": "A list of key/value pairs to replace matched content with.",
          "items": {
            "$ref": "#/definitions/MappedValueReplacePair"
          },
          "type": "array"
        },
        "use_default": {
          "description": "If `true`, specifies a default value if no matching key is found. If\n`false`, the value will be unchanged if no matching key is found.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ReplaceFieldReplaceMode": {
      "description": " - HASH: Replace the matched content with a hashed string, which can help reduce the\nsize of large strings. After replacing the original content with a string,\ntheres no way to recover that information.\n - STATIC_VALUE: Replace the matched content with a static string. For example, replace\npunctuation in a field with an empty string, or truncate the ends of long\nstack traces.\n - MAPPED_VALUE: Replace the matched content with specified key/value pairs. For example,\nreduce log volume by replacing a string error with a specific error code. If\nnone of the key/value pairs match, the provided default value is used.\n\n@REQUIRED",
      "enum": [
        "HASH",
        "STATIC_VALUE",
        "MAPPED_VALUE"
      ],
      "type": "string"
    },
    "ReplaceFieldStaticValue": {
      "description": "StaticValue is the configuration for the replace field control rule in static value\nmode. Used to replace the selected content with a static value.",
      "properties": {
        "value": {
          "description": "The value to replace selected content with. If empty, the action removes the\nselected content.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ResourceAttributesFilterMode": {
      "enum": [
        "APPEND_DEFAULT_EXCLUDE_KEYS",
        "CUSTOM_EXCLUDE_KEYS"
      ],
      "type": "string"
    },
    "ResourceAttributesFlattenMode": {
      "enum": [
        "MERGE",
        "OVERWRITE",
        "IGNORE"
      ],
      "type": "string"
    },
    "ResourceChange": {
      "properties": {
        "action": {
          "$ref": "#/definitions/ResourceChangeAction"
        },
        "resource": {
          "$ref": "#/definitions/configv1ResourceType"
        },
        "slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ResourceChangeAction": {
      "enum": [
        "CREATED",
        "UPDATED",
        "DELETED",
        "NOOP"
      ],
      "type": "string"
    },
    "ResourcePoolsAllocationThreshold": {
      "properties": {
        "fixed_value": {
          "description": "Threshold expressed as a fixed value of the license.",
          "format": "int64",
          "type": "string"
        },
        "percent_of_pool_allocation": {
          "description": "Threshold expressed as a percent of the license allocated to a pool. A value\nof `100` represents a threshold that is the pool's full allocation. Values\nover `100` indicate thresholds that exceed the pool's allocation. For\nexample, a value of `50` represents a threshold that is half the pool's\nallocation, and a value of `200` represents a threshold that is double the\npool's allocation.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "ResourcePoolsDefaultPool": {
      "properties": {
        "allocation": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ResourcePoolsAllocation"
            }
          ],
          "description": "**DEPRECATED**. The default pool receives any remaining allocation after\naccounting for the sum total allocation across pools."
        },
        "priorities": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourcePoolsPriorities"
            }
          ],
          "description": "Optional. Sets priorities that define which metrics within the default pool\nshould be dropped first (low priority) and dropped last (high priority) when\nthe license limit is exceeded. Any metric not matched by either\n`low_priority_filters` or `high_priority_filters` is considered default\npriority, where it is dropped after low but before high.\nSee the [product documentation](https://docs.chronosphere.io/control/shaping/quotas/define-pools#configure-priority)\nfor more information."
        },
        "priority_thresholds": {
          "description": "Optional. For supported licenses, defines thresholds with strict limits for\nwhen to drop new consumption of the license for a pool. Only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported. See the [product documentation](https://docs.chronosphere.io/control/shaping/quotas/define-pools#pool-thresholds)\nfor more information.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResourcePoolsLicense": {
      "enum": [
        "PERSISTED_WRITES_STANDARD",
        "PERSISTED_WRITES_HISTOGRAM",
        "PERSISTED_CARDINALITY_STANDARD",
        "PERSISTED_CARDINALITY_HISTOGRAM",
        "MATCHED_WRITES_STANDARD",
        "MATCHED_WRITES_HISTOGRAM"
      ],
      "type": "string"
    },
    "ResourcePoolsPool": {
      "properties": {
        "allocation": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ResourcePoolsAllocation"
            }
          ],
          "description": "Defines the allocation of the pool."
        },
        "filters": {
          "description": "Filters that define which metrics map to this pool, where any metric that\nmatches at least one filter will map to the pool.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "name": {
          "description": "Name of the pool, which must be unique.",
          "type": "string"
        },
        "priorities": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourcePoolsPriorities"
            }
          ],
          "description": "Optional. Sets priorities that define which metrics within the default pool\nshould be dropped first (low priority) and dropped last (high priority) when\nthe license limit is exceeded. Any metric not matched by either\n`low_priority_filters` or `high_priority_filters` is considered default\npriority, where it is dropped after low but before high."
        }
      },
      "required": [
        "allocation",
        "filters",
        "name"
      ],
      "type": "object"
    },
    "ResourcePoolsPriorities": {
      "properties": {
        "high_priority_filters": {
          "description": "Optional. Filters that define which metrics are high priority. Any metric that\nmatches at least one filter is considered high priority. High priority metrics\nare dropped last when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "low_priority_filters": {
          "description": "Optional. Filters that define which metrics are low priority. Any metric that\nmatches at least one filter is considered low priority. Low priority metrics\nare dropped first when the license limit is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResponderResponderType": {
      "enum": [
        "TEAM",
        "USER",
        "ESCALATION",
        "SCHEDULE"
      ],
      "type": "string"
    },
    "RollupRuleGraphiteLabelPolicy": {
      "properties": {
        "replace": {
          "description": "List of labels to replace. Use to discard high-cardinality values while still\npreserving the original positions of the Graphite metric.",
          "items": {
            "$ref": "#/definitions/GraphiteLabelPolicyReplace"
          },
          "type": "array"
        }
      },
      "required": [
        "replace"
      ],
      "type": "object"
    },
    "RollupRuleLabelReplace": {
      "description": "Must keep this around for backwards compatibility because terraform will\nstill send this key w/ a null value.",
      "type": "object"
    },
    "RollupRuleMetricType": {
      "description": " - CUMULATIVE_COUNTER: Alias of COUNTER.\n - DELTA_COUNTER: Alias of DELTA.",
      "enum": [
        "COUNTER",
        "GAUGE",
        "DELTA",
        "DISTRIBUTION",
        "CUMULATIVE_EXPONENTIAL_HISTOGRAM",
        "MEASUREMENT",
        "CUMULATIVE_COUNTER",
        "DELTA_COUNTER",
        "DELTA_EXPONENTIAL_HISTOGRAM"
      ],
      "type": "string"
    },
    "RoutesNotifierList": {
      "properties": {
        "notifier_slugs": {
          "description": "The slugs of the notifiers that will receive the alerts.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "repeat_interval_secs": {
          "description": "The frequency at which to resend alerts.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "RoutesSeverityNotifiers": {
      "properties": {
        "critical": {
          "allOf": [
            {
              "$ref": "#/definitions/RoutesNotifierList"
            }
          ],
          "description": "The notifiers that will receive `critical` alerts."
        },
        "warn": {
          "allOf": [
            {
              "$ref": "#/definitions/RoutesNotifierList"
            }
          ],
          "description": "The notifiers that will receive `warn` alerts."
        }
      },
      "type": "object"
    },
    "SLICustomIndicatorConfig": {
      "description": "Configuration for error ratio SLIs. You can include these variables in PromQL\nqueries for SLIs:\n- `{{.Window}}`: Specifies the window of time that the PromQL query operates on.\n- `{{.GroupBy}}`: Specifies a comma-separated list of signal and dimension\n  labels to group the results by.\n- `{{.AdditionalFilters}}`: Requires setting `additional_promql_filters`.",
      "properties": {
        "bad_query_template": {
          "description": "A PromQL query that measures the number of \"bad\" events for this SLI.\nEither this or `good_query_template` must be set.",
          "type": "string"
        },
        "good_query_template": {
          "description": "A PromQL query that measures the number of \"good\" events for this SLI.\nEither this or `bad_query_template` must be set.",
          "type": "string"
        },
        "total_query_template": {
          "description": "A PromQL query that measures the total number of events for this SLI.\nThis is required for all error ratio SLOs.",
          "type": "string"
        }
      },
      "required": [
        "total_query_template"
      ],
      "type": "object"
    },
    "SLICustomTimeSliceIndicatorConfig": {
      "description": "Defines the configuration for time slice SLIs. Time slice SLIs are evaluated by\nrunning a PromQL query over a certain time window and comparing the result against\na condition. You can include these variables in PromQL queries for SLIs:\n- `{{.Window}}`: Specifies the window of time that the PromQL query operates on.\n- `{{.GroupBy}}`: Specifies a comma-separated list of signal and dimension labels\n  to group the results by.\n- `{{.TimeSlice}}`: The time slice being evaluated, such as `1m` or `5m`.\n- `{{.AdditionalFilters}}`: Requires setting `additional_promql_filters`.",
      "properties": {
        "condition": {
          "allOf": [
            {
              "$ref": "#/definitions/SLITimeSliceCondition"
            }
          ],
          "description": "The condition to use for the SLI."
        },
        "query_template": {
          "description": "A PromQL query template for the time slice SLI.",
          "type": "string"
        },
        "timeslice_size": {
          "allOf": [
            {
              "$ref": "#/definitions/SLITimeSliceSize"
            }
          ],
          "description": "The size of the time slice to use for the SLI."
        }
      },
      "type": "object"
    },
    "SLITimeSliceCondition": {
      "description": "Defines the condition for evaluating time slice SLIs.",
      "properties": {
        "op": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionOp"
            }
          ],
          "description": "The comparison operation to use."
        },
        "value": {
          "description": "The value to compare against.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "SLITimeSliceSize": {
      "description": "Defines the supported time slice sizes for time slice SLIs.",
      "enum": [
        "TIMESLICE_SIZE_ONE_MINUTE",
        "TIMESLICE_SIZE_FIVE_MINUTES"
      ],
      "type": "string"
    },
    "SLODefinition": {
      "properties": {
        "burn_rate_alerting_config": {
          "description": "Provides the burn rate alert configuration for the SLO. If not provided, the\ndefault burn rates are used. The configuration is only valid if the\n`enable_burn_rate_alerting` flag is set to `true`.",
          "items": {
            "$ref": "#/definitions/DefinitionBurnRateDefinition"
          },
          "type": "array"
        },
        "enable_burn_rate_alerting": {
          "description": "If `true`, enables burn rate alerting.",
          "type": "boolean"
        },
        "objective": {
          "description": "The SLO target percentage, which represents the availability of the SLO.",
          "example": "99.9995",
          "format": "double",
          "type": "number"
        },
        "time_window": {
          "allOf": [
            {
              "$ref": "#/definitions/DefinitionTimeWindow"
            }
          ],
          "description": "Specifies the duration over which the SLO is evaluated. The SLO is considered\nbreached if the error budget is depleted in this window. Default: `4w` (4\nweeks).",
          "example": "4w"
        }
      },
      "type": "object"
    },
    "ScheduleDayActive": {
      "enum": [
        "ALL_DAY",
        "ONLY_DURING_RANGES",
        "NEVER"
      ],
      "type": "string"
    },
    "ScheduleDayTimeRange": {
      "properties": {
        "end_hh_mm": {
          "description": "End time in the in format `\"\u003chour\u003e:\u003cminute\u003e\"`. For example, `\"15:30\"`.",
          "type": "string"
        },
        "start_hh_mm": {
          "description": "Start time in the in format `\"\u003chour\u003e:\u003cminute\u003e\"`. For example, `\"15:30\"`.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ScheduleScheduleDay": {
      "properties": {
        "active": {
          "allOf": [
            {
              "$ref": "#/definitions/ScheduleDayActive"
            }
          ],
          "description": "Determines when the monitor is active for the specified day. Accepts these\nvalues:\n- `ALL_DAY`: The monitor is active all day.\n- `ONLY_DURING_RANGES`: The monitor is only active during the given ranges.\n- `NEVER`: The monitor is never active during the selected day."
        },
        "ranges": {
          "description": "The time ranges that the monitor is active on this day. Required if `active`\nis set to `ONLY_DURING_RANGES`. Otherwise, this field must be empty.",
          "items": {
            "$ref": "#/definitions/ScheduleDayTimeRange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ScheduleWeeklySchedule": {
      "properties": {
        "friday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "monday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "saturday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "sunday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "thursday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "tuesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        },
        "wednesday": {
          "$ref": "#/definitions/ScheduleScheduleDay"
        }
      },
      "type": "object"
    },
    "SeriesConditionsConditions": {
      "properties": {
        "conditions": {
          "description": "List of conditions to evaluate against a series. Only one condition must\nmatch to assign a severity to a signal.",
          "items": {
            "$ref": "#/definitions/configv1MonitorCondition"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SeriesConditionsSeverityConditions": {
      "properties": {
        "critical": {
          "allOf": [
            {
              "$ref": "#/definitions/SeriesConditionsConditions"
            }
          ],
          "description": "Defines the criteria that must be met to trigger a critical condition."
        },
        "warn": {
          "allOf": [
            {
              "$ref": "#/definitions/SeriesConditionsConditions"
            }
          ],
          "description": "Defines the criteria that must be met to trigger a warning condition."
        }
      },
      "type": "object"
    },
    "ServiceAccountMetricsRestriction": {
      "properties": {
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Specifies labels that further restrict the service account to only\nread or write metrics with the given label names and values.",
          "type": "object"
        },
        "permission": {
          "allOf": [
            {
              "$ref": "#/definitions/MetricsRestrictionPermission"
            }
          ],
          "description": "Permission that defines the access level of the service account to only metric data:\n- `READ` grants read-only access.\n- `WRITE` grants write-only access.\n- `READ_WRITE` grants read and write access."
        }
      },
      "required": [
        "permission"
      ],
      "type": "object"
    },
    "SlackConfigConfirmationField": {
      "properties": {
        "dismiss_text": {
          "type": "string"
        },
        "ok_text": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "title": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SlackConfigField": {
      "properties": {
        "short": {
          "type": "boolean"
        },
        "title": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SpanFilterSpanFilterMatchType": {
      "enum": [
        "INCLUDE",
        "EXCLUDE"
      ],
      "type": "string"
    },
    "StringFilterStringFilterMatchType": {
      "enum": [
        "EXACT",
        "REGEX",
        "EXACT_NEGATION",
        "REGEX_NEGATION",
        "IN",
        "NOT_IN"
      ],
      "type": "string"
    },
    "ThresholdInstantRate": {
      "properties": {
        "fixed_value_per_sec": {
          "description": "Value of the fixed rate threshold.",
          "format": "int64",
          "type": "string"
        }
      },
      "required": [
        "fixed_value_per_sec"
      ],
      "type": "object"
    },
    "ThresholdVolume": {
      "properties": {
        "fixed_value": {
          "description": "Value of the volume threshold.",
          "format": "int64",
          "type": "string"
        }
      },
      "required": [
        "fixed_value"
      ],
      "type": "object"
    },
    "TraceBehaviorConfigMainBehaviorAssignment": {
      "properties": {
        "behavior_slug": {
          "description": "The slug reference of a trace behavior.",
          "type": "string"
        },
        "created_at": {
          "description": "The timestamp of when the trace behavior was created.",
          "format": "date-time",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the behavior assignment.",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a trace dataset.",
          "type": "string"
        },
        "description": {
          "description": "A description of the behavior assignment.",
          "type": "string"
        },
        "updated_at": {
          "description": "The timestamp of when the trace behavior was updated.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorConfigOverrideBehaviorAssignment": {
      "properties": {
        "behavior_slug": {
          "description": "The slug reference of a trace behavior.",
          "type": "string"
        },
        "created_at": {
          "description": "The timestamp of when the override behavior assignment was created.",
          "format": "date-time",
          "type": "string"
        },
        "created_by": {
          "description": "The author or creator of the override.",
          "type": "string"
        },
        "dataset_slug": {
          "description": "The slug reference of a trace dataset.",
          "type": "string"
        },
        "description": {
          "description": "A description of the override.",
          "type": "string"
        },
        "end_time": {
          "description": "The ending time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "start_time": {
          "description": "The starting time of the override.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "The timestamp of when the override behavior assignment was updated.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceBehaviorErrorSampleOptions": {
      "properties": {
        "enabled": {
          "description": "Determines whether or not to define options for error traces.",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "Specifies the sample rate for traces with errors.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorSamplingType"
            }
          ],
          "description": "Specifies the sampling type."
        }
      },
      "type": "object"
    },
    "TraceBehaviorFastSampleOptions": {
      "properties": {
        "enabled": {
          "description": "Determines whether or not to define options for fast traces.",
          "type": "boolean"
        },
        "max_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled according to the given\nsample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorSamplingType"
            }
          ],
          "description": "Specifies the sampling type."
        }
      },
      "type": "object"
    },
    "TraceBehaviorLargeTraceSampleOptions": {
      "properties": {
        "enabled": {
          "description": "Determines whether or not to define options for large traces.",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorSamplingType"
            }
          ],
          "description": "Specifies the sampling type."
        },
        "span_count_threshold": {
          "description": "Defines the sampling rate for large traces. If the number of spans in the\ntrace is grater than or equal to (`\u003e=`) the `span_count_threshold`, the trace\nis sampled according to the given sample rate.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceBehaviorSamplingType": {
      "description": " - LOW_VALUE: Match indicates a low value trace. With multiple low value matches sample at the lowest rate.\n - HIGH_VALUE: Match indicates a high value trace. With multiple high value matches sample at the highest rate.",
      "enum": [
        "LOW_VALUE",
        "HIGH_VALUE"
      ],
      "type": "string"
    },
    "TraceBehaviorSlowSampleOptions": {
      "properties": {
        "enabled": {
          "description": "Determines whether or not to define options for slow traces.",
          "type": "boolean"
        },
        "min_duration_seconds": {
          "description": "Duration in seconds under which traces are sampled according to the given\nsample rate.",
          "format": "double",
          "type": "number"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorSamplingType"
            }
          ],
          "description": "Specifies the sampling type."
        }
      },
      "type": "object"
    },
    "TraceBehaviorSmallTraceSampleOptions": {
      "properties": {
        "enabled": {
          "description": "Determines whether or not to define options for small traces.",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "Defines the sample rate for traces during a specified duration.",
          "format": "double",
          "type": "number"
        },
        "sampling_type": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorSamplingType"
            }
          ],
          "description": "Specifies the sampling type."
        },
        "span_count_threshold": {
          "description": "Defines the sampling rate for small traces. If the number of spans in the\ntrace is less than or equal to (`\u003c=`) the `span_count_threshold`, the trace is\nsampled according to the given sample rate.",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyAppliedStrategy": {
      "properties": {
        "per_operation_strategies": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies"
            }
          ],
          "description": "Applies an operation-granularity strategy. If this strategy is set, no other strategy\ncan be set."
        },
        "probabilistic_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyProbabilisticStrategy"
            }
          ],
          "description": "Applies a probabilistic strategy. If this strategy is set, no other strategy\ncan be set."
        },
        "rate_limiting_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy"
            }
          ],
          "description": "Applies a rate-limiting strategy. If this strategy is set, no other strategy\ncan be set."
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyPerOperationSamplingStrategies": {
      "properties": {
        "default_lower_bound_traces_per_second": {
          "description": "Defines a minimum number of traces to send for any operation in the service,\nregardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "default_sampling_rate": {
          "description": "Defines the service-wide sampling probability (in the range `[0, 1]`) when\nspecific operations are not matched.",
          "format": "double",
          "type": "number"
        },
        "default_upper_bound_traces_per_second": {
          "description": "Defines a maximum number of traces to send for any operation in the service,\nregardless of matching per operation strategy.",
          "format": "double",
          "type": "number"
        },
        "per_operation_strategies": {
          "description": "Defines explicit operations-specific strategies that take precedence over the\ndefault sampling rate.",
          "items": {
            "$ref": "#/definitions/PerOperationSamplingStrategiesPerOperationSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyProbabilisticStrategy": {
      "properties": {
        "sampling_rate": {
          "description": "Value in the range `[0, 1]` that defines the percentage probability of\nsampling any trace, where `0` is zero percent and `1` equals 100 percent.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceJaegerRemoteSamplingStrategyRateLimitingSamplingStrategy": {
      "properties": {
        "max_traces_per_second": {
          "description": "Maximum number of traces to sample per second.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterBoolFilter": {
      "properties": {
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterCountFilter": {
      "properties": {
        "max": {
          "description": "Maximum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        },
        "min": {
          "description": "Minimum number of spans that must match a span query, inclusive.",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterDurationFilter": {
      "properties": {
        "max_secs": {
          "description": "Maximum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        },
        "min_secs": {
          "description": "Minimum duration, in seconds, required for a span or trace to match.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterNumericFilter": {
      "properties": {
        "comparison": {
          "allOf": [
            {
              "$ref": "#/definitions/NumericFilterComparisonType"
            }
          ],
          "description": "The comparison operation to apply to an input against the given query value."
        },
        "value": {
          "description": "The filter value used in comparison against match candidates.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterScopeFilter": {
      "properties": {
        "span_scopes": {
          "description": "Specifies the span filters that define which spans contribute to the metrics calculation.\nOnly spans matching these filters will be included in the metrics aggregation.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterSpanFilter": {
      "properties": {
        "duration": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterDurationFilter"
            }
          ],
          "description": "Matches the duration of the candidate span."
        },
        "error": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterBoolFilter"
            }
          ],
          "description": "Matches the error status of the candidate span."
        },
        "is_root_span": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterBoolFilter"
            }
          ],
          "description": "Matches the root span of a trace. For example, if the parent span has no child\nspans."
        },
        "match_type": {
          "allOf": [
            {
              "$ref": "#/definitions/SpanFilterSpanFilterMatchType"
            }
          ],
          "description": "If `INCLUDE`, includes all traces that have at least one (or `span_count`)\nspans matching the query. If `EXCLUDE`, excludes all traces that have at least\none (or `span_count`) spans matching the query."
        },
        "operation": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "Matches the operation of the candidate span."
        },
        "parent_operation": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "If not a root span, matches the operation of the candidate span's parent span"
        },
        "parent_service": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "If not a root span, matches the service of the candidate span's parent span."
        },
        "service": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "Matches the service of the candidate span."
        },
        "span_count": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterCountFilter"
            }
          ],
          "description": "Defines the number of spans that must match the criteria defined by the span\nquery. Defaults to requiring that at least one span matches the span query."
        },
        "tags": {
          "description": "Matches the tags of the candidate span.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterTagFilter"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterStringFilter": {
      "properties": {
        "in_values": {
          "description": "Values the filter tests against when using `IN` or `NOT_IN` match type.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "match": {
          "allOf": [
            {
              "$ref": "#/definitions/StringFilterStringFilterMatchType"
            }
          ],
          "description": "Specifies the comparison operator for the query. If `EXACT`, compared strings\nmust have the exact value of the query value."
        },
        "value": {
          "description": "The value of the filter compared to the target trace or span field.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTagFilter": {
      "properties": {
        "key": {
          "description": "The key or name of the span tag that this filter inspects.",
          "type": "string"
        },
        "numeric_value": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterNumericFilter"
            }
          ],
          "description": "If the query matches the tag with the specified key, and the value type is\n`numeric`, specifies the matcher used to evaluate the span tag value."
        },
        "value": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterStringFilter"
            }
          ],
          "description": "If the query matches the tag with the specified key, and the value type is a\n`string`, specifies the matcher used to evaluate the span tag value."
        }
      },
      "type": "object"
    },
    "TraceSearchFilterTraceFilter": {
      "properties": {
        "duration": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterDurationFilter"
            }
          ],
          "description": "Matches traces based on the duration of the entire trace."
        },
        "error": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterBoolFilter"
            }
          ],
          "description": "Matches traces based on the top-level error status."
        }
      },
      "type": "object"
    },
    "WebhookActionHTTPMethod": {
      "enum": [
        "GET",
        "POST",
        "PUT",
        "PATCH",
        "DELETE",
        "HEAD",
        "OPTIONS"
      ],
      "type": "string"
    },
    "apiError": {
      "properties": {
        "message": {
          "description": "An error message describing what went wrong.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "commonPromQLMatcher": {
      "properties": {
        "name": {
          "description": "Prometheus label name for the matcher",
          "type": "string"
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/commonPromQLMatcherType"
            }
          ],
          "description": "The type of match to be performed"
        },
        "value": {
          "description": "Prometheus label value for the matcher",
          "type": "string"
        }
      },
      "type": "object"
    },
    "commonPromQLMatcherType": {
      "enum": [
        "MatchEqual",
        "MatchRegexp",
        "MatchNotEqual",
        "MatchNotRegexp"
      ],
      "type": "string"
    },
    "configv1AggregationType": {
      "enum": [
        "LAST",
        "MIN",
        "MAX",
        "MEAN",
        "MEDIAN",
        "COUNT",
        "SUM",
        "SUMSQ",
        "STDEV",
        "P10",
        "P20",
        "P30",
        "P40",
        "P50",
        "P60",
        "P70",
        "P80",
        "P90",
        "P95",
        "P99",
        "P999",
        "P9999",
        "P25",
        "P75",
        "COUNT_SAMPLES",
        "HISTOGRAM"
      ],
      "type": "string"
    },
    "configv1AzureMetricsIntegration": {
      "properties": {
        "count_metrics_enabled": {
          "description": "Enables Azure count metrics for the configured resources.",
          "type": "boolean"
        },
        "created_at": {
          "description": "Timestamp of when the AzureMetricsIntegration was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "name": {
          "description": "The name of the AzureMetricsIntegration. You can modify this value after the AzureMetricsIntegration is created.",
          "type": "string"
        },
        "principal": {
          "allOf": [
            {
              "$ref": "#/definitions/AzureMetricsIntegrationAzurePrincipal"
            }
          ],
          "description": "The Azure principal that should be used for this config."
        },
        "propagate_tags": {
          "description": "Specifies whether Azure resource, group, and subscription tags should be propagated as metric labels.",
          "type": "boolean"
        },
        "scrape_config": {
          "allOf": [
            {
              "$ref": "#/definitions/AzureMetricsIntegrationAzureScrapeConfig"
            }
          ],
          "description": "Specifies the scrape config for this integration."
        },
        "slug": {
          "description": "The unique identifier of the AzureMetricsIntegration. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the AzureMetricsIntegration is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the AzureMetricsIntegration was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "usage_metrics_enabled": {
          "description": "Enables collection of azure usage metrics under this principal (Microsoft.Compute, Microsoft.Network, Microsoft.Storage).",
          "type": "boolean"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1Bucket": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the Bucket was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional description of the bucket.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels marking the bucket.",
          "type": "object"
        },
        "name": {
          "description": "The name of the Bucket. You can modify this value after the Bucket is created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this bucket.\nThis is optional if the bucket does not contain monitors or all of its monitors explicitly reference a policy.\nThis policy takes precedence over a bucket-owned notification policy.\nThis does not override the policy used when a monitor explicitly references a policy.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Bucket. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Bucket is created.",
          "type": "string"
        },
        "team_slug": {
          "description": "Optional slug of the team the bucket belongs to.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Bucket was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1Collection": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the Collection was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "A description of the collection.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Collection. You can modify this value after the Collection is created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "The slug of the default notification policy for monitors in this collection.\nThis value is only required when the collection contains monitors and one\nor more of those monitors don't explicitly reference a policy. This value does\nnot override the policy used when a monitor explicitly references a different\npolicy.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Collection. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Collection is created.",
          "type": "string"
        },
        "team_slug": {
          "description": "The slug of the team that the collection belongs to.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Collection was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name",
        "team_slug"
      ],
      "type": "object"
    },
    "configv1CollectionReference": {
      "properties": {
        "slug": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/configv1CollectionReferenceType"
        }
      },
      "type": "object"
    },
    "configv1CollectionReferenceType": {
      "description": "Type values must match entitiespb.Collection.CollectionType.",
      "enum": [
        "SIMPLE",
        "SERVICE"
      ],
      "type": "string"
    },
    "configv1ConsumptionBudget": {
      "properties": {
        "alert_action_config": {
          "allOf": [
            {
              "$ref": "#/definitions/ConsumptionBudgetAlertActionConfig"
            }
          ],
          "description": "Optional. Configures all `ALERT_WARN` \u0026 `ALERT_CRITICAL` actions for this budget."
        },
        "created_at": {
          "description": "Timestamp of when the ConsumptionBudget was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_priority": {
          "description": "Optional. The default priority for requests that don't match any priority in the\n`priorities` list. If not set, then `priority=10` (dropped first) is used as the\ndefault.",
          "format": "int32",
          "type": "integer"
        },
        "name": {
          "description": "The name of the ConsumptionBudget. You can modify this value after the ConsumptionBudget is created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Notification policy slug for routing alerts. Required only if `ALERT_WARN` or\n`ALERT_CRITICAL` actions are configured.",
          "type": "string"
        },
        "partition_slug_path": {
          "description": "Path of the budget's partition, delimited by forward slashes (`/`), in the\nformat `global/SLUG1/SLUG2`, where `SLUG1` is a top-level partition, and `SLUG2`\nis a child partition of `SLUG1`.\n\nA well-formed partition path always starts with the `global` partition slug, and\nhas no leading or trailing forward slashes.",
          "type": "string"
        },
        "priorities": {
          "description": "Optional. Controls the order in which data is dropped when a drop action is\napplied. For example, a priority of 10 is dropped first, and a priority of 1 is\ndropped last. Priorities are evaluated in match order, and the first priority to\nmatch is applied. All other priorities are ignored. If a request does not match\nany priority, then it is assigned the `default_priority`.",
          "items": {
            "$ref": "#/definitions/ConsumptionBudgetPriority"
          },
          "type": "array"
        },
        "resource": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ConsumptionBudgetResource"
            }
          ],
          "description": "Resource of the budget."
        },
        "slug": {
          "description": "The unique identifier of the ConsumptionBudget. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the ConsumptionBudget is created.",
          "type": "string"
        },
        "thresholds": {
          "description": "Optional. Defines which actions to take when a threshold is exceeded.",
          "items": {
            "$ref": "#/definitions/configv1ConsumptionBudgetThreshold"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the ConsumptionBudget was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name",
        "partition_slug_path",
        "resource"
      ],
      "type": "object"
    },
    "configv1ConsumptionBudgetResource": {
      "enum": [
        "LOG_PERSISTED_BYTES",
        "LOG_PROCESSED_BYTES"
      ],
      "type": "string"
    },
    "configv1ConsumptionBudgetThreshold": {
      "properties": {
        "action": {
          "allOf": [
            {
              "$ref": "#/definitions/ConsumptionBudgetThresholdAction"
            }
          ],
          "description": "The specified action to take when the threshold is exceeded."
        },
        "instant_rate": {
          "allOf": [
            {
              "$ref": "#/definitions/ThresholdInstantRate"
            }
          ],
          "description": "Configures the `INSTANT_RATE` threshold type."
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/ConsumptionBudgetThresholdType"
            }
          ],
          "description": "Specifies the threshold type, which can be one of the following values.\n\n`INSTANT_RATE` sets an instantaneous rate threshold. The configured action\ntriggers when consumption exceeds the configured rate threshold, defined by\nthe `instant_rate` field. The `DROP` action accepts requests up to the\nthreshold, and drops any data over the threshold in priority order.\n\n`ROLLING_1_HOUR_VOLUME` and `ROLLING_3_HOUR_VOLUME` set a volume\nthreshold over a rolling time period. The configured action triggers when\nconsumption over the last hour or last three hours exceeds the\nconfigured threshold, defined by the `volume` field.\n\n`HOURLY_VOLUME`, `DAILY_VOLUME`, `WEEKLY_VOLUME`, and `MONTHLY_VOLUME` set a volume threshold\nover a fixed, non-overlapping time period. The configured action triggers when consumption\nover the specified time period (hourly, daily, weekly, or monthly) exceeds the\nconfigured threshold, defined by the `volume` field. Volumes reset\nto zero at the start of each time period. The `DROP` action drops all requests\nwhen a volume threshold is exceeded, regardless of priority.\n\n- `HOURLY_VOLUME` sums the consumption volume from `00:00:00` UTC` to `00:59:59` UTC\n  every hour.\n- `DAILY_VOLUME` sums the consumption volume from `00:00:00` UTC to `23:59:59` UTC\n  every day.\n- `WEEKLY_VOLUME` sums the consumption volume from `00:00:00` UTC Monday morning\n  to `23:59:59` UTC Sunday night.\n- `MONTHLY_VOLUME` sums the consumption volume from `00:00:00` UTC on the first\n  day of the month to `23:59:59` UTC on the last day of the month. For example,\n  `Jan 1 00:00:00` to `Jan 31 23:59:59`. Month thresholds are evaluated equally,\n  regardless of how many days are in the month. For example, thresholds for\n  January and February are the same, even though February has fewer days."
        },
        "volume": {
          "allOf": [
            {
              "$ref": "#/definitions/ThresholdVolume"
            }
          ],
          "description": "Configures the `VOLUME` threshold type."
        }
      },
      "required": [
        "action",
        "type"
      ],
      "type": "object"
    },
    "configv1ConsumptionConfig": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ConsumptionConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "partitions": {
          "description": "Partitions define non-overlapping groupings of telemetry data. Partitions are\ndefined in order of precedence, where incoming requests are allocated to the\nfirst partition that matches. Requests that don't match any partition use an\nimplicit `default` partition.",
          "items": {
            "$ref": "#/definitions/ConsumptionConfigPartition"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the ConsumptionConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CreateAzureMetricsIntegrationRequest": {
      "properties": {
        "azure_metrics_integration": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1AzureMetricsIntegration"
            }
          ],
          "description": "The AzureMetricsIntegration to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the AzureMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the AzureMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1CreateBucketRequest": {
      "properties": {
        "bucket": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Bucket"
            }
          ],
          "description": "The Bucket to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Bucket. If the specified configuration is valid, the endpoint returns a partial response without the Bucket. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardRequest": {
      "properties": {
        "classic_dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GrafanaDashboard"
            }
          ],
          "description": "The GrafanaDashboard to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionRequest": {
      "properties": {
        "collection": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Collection"
            }
          ],
          "description": "The Collection to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Collection. If the specified configuration is valid, the endpoint returns a partial response without the Collection. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionBudgetRequest": {
      "properties": {
        "consumption_budget": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ConsumptionBudget"
            }
          ],
          "description": "The ConsumptionBudget to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ConsumptionBudget. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionBudget. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionConfigRequest": {
      "properties": {
        "consumption_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ConsumptionConfig"
            }
          ],
          "description": "The ConsumptionConfig to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ConsumptionConfig. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardRequest": {
      "properties": {
        "dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Dashboard"
            }
          ],
          "description": "The Dashboard to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Dashboard. If the specified configuration is valid, the endpoint returns a partial response without the Dashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetRequest": {
      "properties": {
        "dataset": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Dataset"
            }
          ],
          "description": "The Dataset to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Dataset. If the specified configuration is valid, the endpoint returns a partial response without the Dataset. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelRequest": {
      "properties": {
        "derived_label": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DerivedLabel"
            }
          ],
          "description": "The DerivedLabel to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the DerivedLabel. If the specified configuration is valid, the endpoint returns a partial response without the DerivedLabel. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricRequest": {
      "properties": {
        "derived_metric": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DerivedMetric"
            }
          ],
          "description": "The DerivedMetric to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the DerivedMetric. If the specified configuration is valid, the endpoint returns a partial response without the DerivedMetric. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleRequest": {
      "properties": {
        "drop_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DropRule"
            }
          ],
          "description": "The DropRule to create."
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the DropRule. If the specified configuration is valid, the endpoint returns a partial response without the DropRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1CreateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the GcpMetricsIntegration. If the specified configuration is valid, the endpoint returns a partial response without the GcpMetricsIntegration. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "gcp_metrics_integration": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GcpMetricsIntegration"
            }
          ],
          "description": "The GcpMetricsIntegration to create."
        }
      },
      "type": "object"
    },
    "configv1CreateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the GrafanaDashboard. If the specified configuration is valid, the endpoint returns a partial response without the GrafanaDashboard. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "grafana_dashboard": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GrafanaDashboard"
            }
          ],
          "description": "The GrafanaDashboard to create."
        }
      },
      "type": "object"
    },
    "configv1CreateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogAllocationConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogAllocationConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_allocation_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogAllocationConfig"
            }
          ],
          "description": "The LogAllocationConfig to create."
        }
      },
      "type": "object"
    },
    "configv1CreateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogControlConfigRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogControlConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogControlConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_control_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogControlConfig"
            }
          ],
          "description": "The LogControlConfig to create."
        }
      },
      "type": "object"
    },
    "configv1CreateLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogIngestConfigRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogIngestConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogIngestConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_ingest_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogIngestConfig"
            }
          ],
          "description": "The LogIngestConfig to create."
        }
      },
      "type": "object"
    },
    "configv1CreateLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogScaleAction. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAction. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_scale_action": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogScaleAction"
            }
          ],
          "description": "The LogScaleAction to create."
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the LogScaleAlert. If the specified configuration is valid, the endpoint returns a partial response without the LogScaleAlert. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_scale_alert": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogScaleAlert"
            }
          ],
          "description": "The LogScaleAlert to create."
        }
      },
      "type": "object"
    },
    "configv1CreateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the MappingRule. If the specified configuration is valid, the endpoint returns a partial response without the MappingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "mapping_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1MappingRule"
            }
          ],
          "description": "The MappingRule to create."
        }
      },
      "type": "object"
    },
    "configv1CreateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Monitor. If the specified configuration is valid, the endpoint returns a partial response without the Monitor. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "monitor": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Monitor"
            }
          ],
          "description": "The Monitor to create."
        }
      },
      "type": "object"
    },
    "configv1CreateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the MutingRule. If the specified configuration is valid, the endpoint returns a partial response without the MutingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "muting_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1MutingRule"
            }
          ],
          "description": "The MutingRule to create."
        }
      },
      "type": "object"
    },
    "configv1CreateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the NotificationPolicy. If the specified configuration is valid, the endpoint returns a partial response without the NotificationPolicy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "notification_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1NotificationPolicy"
            }
          ],
          "description": "The NotificationPolicy to create."
        }
      },
      "type": "object"
    },
    "configv1CreateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Notifier. If the specified configuration is valid, the endpoint returns a partial response without the Notifier. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "notifier": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Notifier"
            }
          ],
          "description": "The Notifier to create."
        }
      },
      "type": "object"
    },
    "configv1CreateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the OtelMetricsIngestion. If the specified configuration is valid, the endpoint returns a partial response without the OtelMetricsIngestion. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "otel_metrics_ingestion": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1OtelMetricsIngestion"
            }
          ],
          "description": "The OtelMetricsIngestion to create."
        }
      },
      "type": "object"
    },
    "configv1CreateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the RecordingRule. If the specified configuration is valid, the endpoint returns a partial response without the RecordingRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "recording_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RecordingRule"
            }
          ],
          "description": "The RecordingRule to create."
        }
      },
      "type": "object"
    },
    "configv1CreateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ResourcePools. If the specified configuration is valid, the endpoint returns a partial response without the ResourcePools. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "resource_pools": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ResourcePools"
            }
          ],
          "description": "The ResourcePools to create."
        }
      },
      "type": "object"
    },
    "configv1CreateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the RollupRule. If the specified configuration is valid, the endpoint returns a partial response without the RollupRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "rollup_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RollupRule"
            }
          ],
          "description": "The RollupRule to create."
        }
      },
      "type": "object"
    },
    "configv1CreateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1CreateSLORequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the SLO. If the specified configuration is valid, the endpoint returns a partial response without the SLO. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "slo": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1SLO"
            }
          ],
          "description": "The SLO to create."
        }
      },
      "type": "object"
    },
    "configv1CreateSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the ServiceAccount. If the specified configuration is valid, the endpoint returns a partial response without the ServiceAccount. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "service_account": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ServiceAccount"
            }
          ],
          "description": "The ServiceAccount to create."
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1CreateServiceAttributeResponse": {
      "properties": {
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        },
        "service_slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1CreateTeamRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the Team. If the specified configuration is valid, the endpoint returns a partial response without the Team. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "team": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1Team"
            }
          ],
          "description": "The Team to create."
        }
      },
      "type": "object"
    },
    "configv1CreateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceBehaviorConfig. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehaviorConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_behavior_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceBehaviorConfig"
            }
          ],
          "description": "The TraceBehaviorConfig to create."
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceBehavior. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehavior. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_behavior": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceBehavior"
            }
          ],
          "description": "The TraceBehavior to create."
        }
      },
      "type": "object"
    },
    "configv1CreateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceJaegerRemoteSamplingStrategy. If the specified configuration is valid, the endpoint returns a partial response without the TraceJaegerRemoteSamplingStrategy. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_jaeger_remote_sampling_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
            }
          ],
          "description": "The TraceJaegerRemoteSamplingStrategy to create."
        }
      },
      "type": "object"
    },
    "configv1CreateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceMetricsRule. If the specified configuration is valid, the endpoint returns a partial response without the TraceMetricsRule. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_metrics_rule": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceMetricsRule"
            }
          ],
          "description": "The TraceMetricsRule to create."
        }
      },
      "type": "object"
    },
    "configv1CreateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesRequest": {
      "properties": {
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating the TraceTailSamplingRules. If the specified configuration is valid, the endpoint returns a partial response without the TraceTailSamplingRules. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_tail_sampling_rules": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceTailSamplingRules"
            }
          ],
          "description": "The TraceTailSamplingRules to create."
        }
      },
      "type": "object"
    },
    "configv1CreateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1Dashboard": {
      "properties": {
        "collection": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1CollectionReference"
            }
          ],
          "description": "Collection that the dashboard belongs to. Required if `collection_slug` is not\nset."
        },
        "collection_slug": {
          "description": "Optional. Slug of the collection the dashboard belongs to.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Dashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "dashboard_json": {
          "description": "Raw JSON representation that defines the structure of the dashboard.",
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional. Defines tags that add metadata about the dashboard.",
          "type": "object"
        },
        "name": {
          "description": "The name of the Dashboard. You can modify this value after the Dashboard is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Dashboard. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Dashboard is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1Dataset": {
      "properties": {
        "configuration": {
          "allOf": [
            {
              "$ref": "#/definitions/DatasetDatasetConfiguration"
            }
          ],
          "description": "Required. Defines the configuration of the dataset."
        },
        "created_at": {
          "description": "Timestamp of when the Dataset was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Required. Description of the dataset.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Dataset. You can modify this value after the Dataset is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Dataset. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Dataset is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Dataset was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1DefaultSampleRate": {
      "properties": {
        "enabled": {
          "description": "Determines whether to override the default sample rate.",
          "type": "boolean"
        },
        "sample_rate": {
          "description": "Specifies the percentage of traces to keep, which must be a number between `0`\nand `1`, inclusive, where `1` equates to 100 percent.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1DeleteAzureMetricsIntegrationResponse": {
      "type": "object"
    },
    "configv1DeleteBucketResponse": {
      "properties": {
        "changes": {
          "description": "Changes contains what resources are deleted. The bucket being deleted will\nalways be included. When force_delete is used, the changelog will include\nall resources that reference the bucket that were deleted.",
          "items": {
            "$ref": "#/definitions/ResourceChange"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1DeleteClassicDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteCollectionResponse": {
      "type": "object"
    },
    "configv1DeleteConsumptionBudgetResponse": {
      "type": "object"
    },
    "configv1DeleteConsumptionConfigResponse": {
      "type": "object"
    },
    "configv1DeleteDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteDatasetResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedLabelResponse": {
      "type": "object"
    },
    "configv1DeleteDerivedMetricResponse": {
      "type": "object"
    },
    "configv1DeleteDropRuleResponse": {
      "type": "object"
    },
    "configv1DeleteGcpMetricsIntegrationResponse": {
      "type": "object"
    },
    "configv1DeleteGrafanaDashboardResponse": {
      "type": "object"
    },
    "configv1DeleteLogAllocationConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogControlConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogIngestConfigResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleActionResponse": {
      "type": "object"
    },
    "configv1DeleteLogScaleAlertResponse": {
      "type": "object"
    },
    "configv1DeleteMappingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteMonitorResponse": {
      "type": "object"
    },
    "configv1DeleteMutingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteNotificationPolicyResponse": {
      "type": "object"
    },
    "configv1DeleteNotifierResponse": {
      "type": "object"
    },
    "configv1DeleteOtelMetricsIngestionResponse": {
      "type": "object"
    },
    "configv1DeleteRecordingRuleResponse": {
      "type": "object"
    },
    "configv1DeleteResourcePoolsResponse": {
      "type": "object"
    },
    "configv1DeleteRollupRuleResponse": {
      "type": "object"
    },
    "configv1DeleteSLOResponse": {
      "type": "object"
    },
    "configv1DeleteServiceAccountResponse": {
      "type": "object"
    },
    "configv1DeleteServiceAttributeResponse": {
      "type": "object"
    },
    "configv1DeleteTeamResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorConfigResponse": {
      "type": "object"
    },
    "configv1DeleteTraceBehaviorResponse": {
      "type": "object"
    },
    "configv1DeleteTraceJaegerRemoteSamplingStrategyResponse": {
      "type": "object"
    },
    "configv1DeleteTraceMetricsRuleResponse": {
      "type": "object"
    },
    "configv1DeleteTraceTailSamplingRulesResponse": {
      "type": "object"
    },
    "configv1DerivedLabel": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the DerivedLabel was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional. Description of the derived label.",
          "type": "string"
        },
        "existing_label_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DerivedLabelLabelPolicy"
            }
          ],
          "description": "Specifies the action taken when there's a metric label with the same name as\nthis derived label, on the same time series. If the label is present on another\ntime series, this field doesn't apply. Default: `KEEP`.\n- If set to `KEEP`, the label that already exists on the metric is used instead of the derived label.\n- If set to `OVERRIDE`, the derived label is used instead of the metric's existing label."
        },
        "label_name": {
          "description": "Name of the derived label. Must be unique across the system.",
          "type": "string"
        },
        "metric_label": {
          "allOf": [
            {
              "$ref": "#/definitions/DerivedLabelMetricLabel"
            }
          ],
          "description": "Sets the metric labels to map to `label_name`."
        },
        "name": {
          "description": "The name of the DerivedLabel. You can modify this value after the DerivedLabel is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the DerivedLabel. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the DerivedLabel is created.",
          "type": "string"
        },
        "span_tag": {
          "allOf": [
            {
              "$ref": "#/definitions/DerivedLabelSpanTag"
            }
          ],
          "description": "Sets the span tags to map to `label_name`."
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedLabel was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "label_name",
        "name"
      ],
      "type": "object"
    },
    "configv1DerivedLabelLabelPolicy": {
      "enum": [
        "KEEP",
        "OVERRIDE"
      ],
      "type": "string"
    },
    "configv1DerivedMetric": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the DerivedMetric was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional. Description of the derived metric.",
          "type": "string"
        },
        "metric_name": {
          "description": "Name of the derived metric, which must be unique across the system.",
          "example": "cpu_usage:instance",
          "type": "string"
        },
        "name": {
          "description": "The name of the DerivedMetric. You can modify this value after the DerivedMetric is created.",
          "type": "string"
        },
        "queries": {
          "description": "Defines the queries that the derived metric can map to.",
          "items": {
            "$ref": "#/definitions/DerivedMetricSelectorQuery"
          },
          "type": "array"
        },
        "slug": {
          "description": "The unique identifier of the DerivedMetric. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the DerivedMetric is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DerivedMetric was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "metric_name",
        "name",
        "queries"
      ],
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcher": {
      "properties": {
        "name": {
          "description": "name always matches against an exact label name.",
          "type": "string"
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DerivedMetricLabelMatcherMatcherType"
            }
          ],
          "description": "type determines how the label value is matched."
        },
        "value": {
          "description": "value matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1DerivedMetricLabelMatcherMatcherType": {
      "enum": [
        "EXACT"
      ],
      "type": "string"
    },
    "configv1DropRule": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the DropRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "drop_nan_value": {
          "description": "Drops data points if values are Not a Number (NaN). If set to true, Chronosphere\ndrops NaN data points, along with any published staleness markers. See the\n[drop rules\ndocumentation](https://docs.chronosphere.io/control/shaping/rules/drop-rules#define-a-value-based-drop-rule)\nfor more information.",
          "type": "boolean"
        },
        "filters": {
          "description": "Defines the conditions that determine whether to drop a metric. Drop rules can\nhave multiple filter conditions on different labels, making it possible to drop\na subset of the series matching a particular metric name.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "mode": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DropRuleMode"
            }
          ],
          "description": "If set to `DISABLED`, then the rule isn't applied when ingesting data points\nand metrics won't be dropped on the basis of this rule."
        },
        "name": {
          "description": "The name of the DropRule. You can modify this value after the DropRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the DropRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the DropRule is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the DropRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "value_based_drop": {
          "allOf": [
            {
              "$ref": "#/definitions/DropRuleValueBasedDrop"
            }
          ],
          "description": "Drops metrics based on values of `0` or `1`. This type of drop rule can\nsignificantly reduce data points per second, but changes metrics from continuous\nseries to sparse metrics. Adding a rule of this type can change the behavior of\nexisting monitors or dashboards that use the target metric."
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1DropRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED",
        "PREVIEW"
      ],
      "type": "string"
    },
    "configv1GcpMetricsIntegration": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "metric_groups": {
          "description": "An array of metric groups to be ingested for this integration.",
          "items": {
            "$ref": "#/definitions/GcpMetricsIntegrationMetricGroup"
          },
          "type": "array"
        },
        "name": {
          "description": "The name of the GcpMetricsIntegration. You can modify this value after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "service_account": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GcpMetricsIntegrationServiceAccount"
            }
          ],
          "description": "The Google Cloud service account to use for API authentication."
        },
        "slug": {
          "description": "The unique identifier of the GcpMetricsIntegration. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the GcpMetricsIntegration is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GcpMetricsIntegration was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1GcpMetricsIntegrationServiceAccount": {
      "properties": {
        "client_email": {
          "description": "The email address of the Google Cloud service account to impersonate for authentication.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1GrafanaDashboard": {
      "properties": {
        "bucket_slug": {
          "description": "Slug of the bucket the dashboard belongs to. Required if collection_slug\nis not set.",
          "type": "string"
        },
        "collection": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1CollectionReference"
            }
          ],
          "description": "Collection that the monitor belongs to. Required if bucket_slug and\ncollection_slug are not set."
        },
        "collection_slug": {
          "description": "Slug of the collection the dashboard belongs to. Required if bucket_slug\nis not set.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the GrafanaDashboard was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "dashboard_json": {
          "description": "Required raw JSON of the Grafana dashboard.",
          "type": "string"
        },
        "name": {
          "description": "The name of the GrafanaDashboard. You can modify this value after the GrafanaDashboard is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the GrafanaDashboard. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the GrafanaDashboard is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the GrafanaDashboard was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1LabelFilter": {
      "properties": {
        "name": {
          "description": "The name of the label to match.",
          "example": "job",
          "type": "string"
        },
        "value_glob": {
          "description": "The glob value of the label to match.",
          "example": "myservice*",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcher": {
      "properties": {
        "name": {
          "description": "The name of the label to match against. This always matches against an\nexact label name, regardless of the value of `type`.",
          "type": "string"
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LabelMatcherMatcherType"
            }
          ],
          "description": "Determines how the label `value` is matched. This parameter doesn't\naffect how the label `name` is matched."
        },
        "value": {
          "description": "The value of the label to match against. If `type` is set to `EXACT`, this\nmatches against an exact label value. If `type` is set to `REGEX`, this\nparameter is treated as a regular expression for parsing label values.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX"
      ],
      "type": "string"
    },
    "configv1ListAzureMetricsIntegrationsResponse": {
      "properties": {
        "azure_metrics_integrations": {
          "items": {
            "$ref": "#/definitions/configv1AzureMetricsIntegration"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListBucketsResponse": {
      "properties": {
        "buckets": {
          "items": {
            "$ref": "#/definitions/configv1Bucket"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListClassicDashboardsResponse": {
      "properties": {
        "classic_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListCollectionsResponse": {
      "properties": {
        "collections": {
          "items": {
            "$ref": "#/definitions/configv1Collection"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListConsumptionBudgetsResponse": {
      "properties": {
        "consumption_budgets": {
          "items": {
            "$ref": "#/definitions/configv1ConsumptionBudget"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListDashboardsResponse": {
      "properties": {
        "dashboards": {
          "items": {
            "$ref": "#/definitions/configv1Dashboard"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListDatasetsResponse": {
      "properties": {
        "datasets": {
          "items": {
            "$ref": "#/definitions/configv1Dataset"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedLabelsResponse": {
      "properties": {
        "derived_labels": {
          "items": {
            "$ref": "#/definitions/configv1DerivedLabel"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListDerivedMetricsResponse": {
      "properties": {
        "derived_metrics": {
          "items": {
            "$ref": "#/definitions/configv1DerivedMetric"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListDropRulesResponse": {
      "properties": {
        "drop_rules": {
          "items": {
            "$ref": "#/definitions/configv1DropRule"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListGcpMetricsIntegrationsResponse": {
      "properties": {
        "gcp_metrics_integrations": {
          "items": {
            "$ref": "#/definitions/configv1GcpMetricsIntegration"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListGrafanaDashboardsResponse": {
      "properties": {
        "grafana_dashboards": {
          "items": {
            "$ref": "#/definitions/configv1GrafanaDashboard"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleActionsResponse": {
      "properties": {
        "log_scale_actions": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAction"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListLogScaleAlertsResponse": {
      "properties": {
        "log_scale_alerts": {
          "items": {
            "$ref": "#/definitions/configv1LogScaleAlert"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListMappingRulesResponse": {
      "properties": {
        "mapping_rules": {
          "items": {
            "$ref": "#/definitions/configv1MappingRule"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListMonitorsResponse": {
      "properties": {
        "monitors": {
          "items": {
            "$ref": "#/definitions/configv1Monitor"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListMutingRulesResponse": {
      "properties": {
        "muting_rules": {
          "items": {
            "$ref": "#/definitions/configv1MutingRule"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListNotificationPoliciesResponse": {
      "properties": {
        "notification_policies": {
          "items": {
            "$ref": "#/definitions/configv1NotificationPolicy"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListNotifiersResponse": {
      "properties": {
        "notifiers": {
          "items": {
            "$ref": "#/definitions/configv1Notifier"
          },
          "type": "array"
        },
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        }
      },
      "type": "object"
    },
    "configv1ListRecordingRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "recording_rules": {
          "items": {
            "$ref": "#/definitions/configv1RecordingRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListRollupRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "rollup_rules": {
          "items": {
            "$ref": "#/definitions/configv1RollupRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListSLOsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "slos": {
          "items": {
            "$ref": "#/definitions/configv1SLO"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServiceAccountsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "service_accounts": {
          "items": {
            "$ref": "#/definitions/configv1ServiceAccount"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServiceAttributesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "service_attributes": {
          "items": {
            "$ref": "#/definitions/configv1ServiceAttribute"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListServicesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "services": {
          "items": {
            "$ref": "#/definitions/configv1Service"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTeamsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "teams": {
          "items": {
            "$ref": "#/definitions/configv1Team"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceBehaviorsResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_behaviors": {
          "items": {
            "$ref": "#/definitions/configv1TraceBehavior"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceJaegerRemoteSamplingStrategiesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_jaeger_remote_sampling_strategies": {
          "items": {
            "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ListTraceMetricsRulesResponse": {
      "properties": {
        "page": {
          "$ref": "#/definitions/configv1PageResult"
        },
        "trace_metrics_rules": {
          "description": "Found trace metrics rules.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRule"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfig": {
      "description": "LogAllocationConfig is a singleton configuration object that specifies the\nconfiguration for Log budget allocations.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogAllocationConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "dataset_allocations": {
          "description": "Defines datasets and budget allocations. Datasets are evaluated in order.",
          "items": {
            "$ref": "#/definitions/LogAllocationConfigDatasetAllocation"
          },
          "type": "array"
        },
        "default_dataset": {
          "allOf": [
            {
              "$ref": "#/definitions/LogAllocationConfigDefaultDataset"
            }
          ],
          "description": "The default dataset applies to logs that aren't included in any other dataset."
        },
        "updated_at": {
          "description": "Timestamp of when the LogAllocationConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LogAllocationConfigAllocation": {
      "description": "Configuration for allocating resources to a dataset.",
      "properties": {
        "percent_of_license": {
          "description": "Sets the percentage of the license limit to allocate to the default dataset.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1LogControlConfig": {
      "description": "LogControlConfig is a singleton configuration object that specifies the\nconfiguration for log control.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogControlConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "rules": {
          "description": "Control Rules are the ordered list of control rules.",
          "items": {
            "$ref": "#/definitions/configv1LogControlRule"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the LogControlConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LogControlRule": {
      "description": "LogControlRule is the configuration for a log control rule.",
      "properties": {
        "drop_field": {
          "allOf": [
            {
              "$ref": "#/definitions/LogControlRuleDropField"
            }
          ],
          "description": "Defines the action to drop fields from logs that match specified conditions,\nwhich helps reduce the size of individual logs. If a log contains no data after\nfields are dropped, you can choose to drop the entire log."
        },
        "emit_metrics": {
          "allOf": [
            {
              "$ref": "#/definitions/LogControlRuleEmitMetrics"
            }
          ],
          "description": "Defines the action to convert log data to metric data. Use this control rule\nwhen you want to reduce the volume of logs, retain data for a longer period, and\nincrease the speed of querying and filtering for metrics instead of logs"
        },
        "filter": {
          "description": "Log query filter to return log data for the control rule. The control action\napplies to only matching logs.",
          "type": "string"
        },
        "mode": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogControlRuleMode"
            }
          ],
          "description": "Specifies whether the control rule is enabled or disabled. Default: `ENABLED`."
        },
        "name": {
          "description": "User-defined name of the control rule.",
          "type": "string"
        },
        "replace_field": {
          "allOf": [
            {
              "$ref": "#/definitions/LogControlRuleReplaceField"
            }
          ],
          "description": "Defines the action to identify a specified field in your log data and uses a\nregular expression to replace any matches based on the selected replacement\nmode. Use this control rule to truncate long fields and preserve your log\nstructure."
        },
        "sample": {
          "allOf": [
            {
              "$ref": "#/definitions/LogControlRuleSample"
            }
          ],
          "description": "Defines the action to retain a certain percentage of matching logs and drop the\nremainder, which can significantly reduce volume and maintain visibility."
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogControlRuleType"
            }
          ],
          "description": "The type of action to take on matching logs. Must be one of the following\nvalues."
        }
      },
      "type": "object"
    },
    "configv1LogControlRuleMode": {
      "enum": [
        "ENABLED",
        "DISABLED"
      ],
      "type": "string"
    },
    "configv1LogControlRuleType": {
      "enum": [
        "DROP",
        "SAMPLE",
        "DROP_FIELD",
        "REPLACE_FIELD",
        "EMIT_METRICS"
      ],
      "type": "string"
    },
    "configv1LogDataset": {
      "properties": {
        "match_criteria": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogSearchFilter"
            }
          ],
          "description": "Required. Defines the criteria to match logs to a dataset."
        }
      },
      "type": "object"
    },
    "configv1LogFieldPath": {
      "properties": {
        "selector": {
          "description": "The log filter used to indicate the field path. Use `parent[child]` syntax to\nindicate nesting.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LogIngestConfig": {
      "description": "LogIngestConfig is a singleton configuration object that specifies the configuration for log ingest.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the LogIngestConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "field_normalization": {
          "allOf": [
            {
              "$ref": "#/definitions/LogIngestConfigFieldNormalization"
            }
          ],
          "description": "Maps and normalizes well-known fields from parsed logs."
        },
        "field_parsers": {
          "description": "The parsers to apply to specific fields within structured logs or plaintext logs after those logs are parsed.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigLogFieldParser"
          },
          "type": "array"
        },
        "plaintext_parsers": {
          "description": "The parsers to apply to plaintext logs. The first parser that matches the log is used.",
          "items": {
            "$ref": "#/definitions/LogIngestConfigPlaintextParser"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the LogIngestConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1LogScaleAction": {
      "properties": {
        "action_type": {
          "$ref": "#/definitions/LogScaleActionActionType"
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAction was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "email_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionEmailAction"
            }
          ],
          "description": "Data for creating an email action."
        },
        "humio_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionHumioRepoAction"
            }
          ],
          "description": "Data for creating a LogScale repository action."
        },
        "name": {
          "description": "Name of an action.",
          "type": "string"
        },
        "ops_genie_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionOpsGenieAction"
            }
          ],
          "description": "Data for creating an OpsGenie action."
        },
        "pager_duty_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionPagerDutyAction"
            }
          ],
          "description": "Data for creating a PagerDuty action."
        },
        "repository": {
          "description": "Name of the LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "slack_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionSlackAction"
            }
          ],
          "description": "Data for creating a Slack action."
        },
        "slack_post_message_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionSlackPostMessageAction"
            }
          ],
          "description": "Data for creating a post message Slack action."
        },
        "slug": {
          "description": "The unique identifier of the LogScaleAction. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the LogScaleAction is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAction was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "upload_file_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionUploadFileAction"
            }
          ],
          "description": "Data for creating an upload file action."
        },
        "victor_ops_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionVictorOpsAction"
            }
          ],
          "description": "Data for creating a VictorOps action."
        },
        "webhook_action": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleActionWebhookAction"
            }
          ],
          "description": "Data for creating a webhook action."
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1LogScaleAlert": {
      "properties": {
        "alert_type": {
          "allOf": [
            {
              "$ref": "#/definitions/LogScaleAlertAlertType"
            }
          ],
          "description": "Type of alert, which can be standard or filter. A standard alert is triggered by\nan aggregate result. A filter alert is triggered by single event."
        },
        "created_at": {
          "description": "Timestamp of when the LogScaleAlert was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Description of the alert.",
          "type": "string"
        },
        "disabled": {
          "description": "Flag indicating whether the alert is disabled.",
          "type": "boolean"
        },
        "log_scale_action_slugs": {
          "description": "Slugs of LogScale actions that will receive the alerts. When the value is empty\nthis alert won't trigger. Optional.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "log_scale_query": {
          "description": "LogScale query to execute.",
          "example": "level = ERROR | severity \u003e 3 | count(as=numErrors) | numErrors \u003e 500",
          "type": "string"
        },
        "name": {
          "description": "Name of the alert.",
          "type": "string"
        },
        "repository": {
          "description": "Name of LogScale repository the alerts belongs to. Required.",
          "type": "string"
        },
        "run_as_user": {
          "description": "Email of the user that the alert runs on behalf of. Required.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the LogScaleAlert. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the LogScaleAlert is created.",
          "type": "string"
        },
        "tags": {
          "description": "Tags attached to the alert.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "throttle_field": {
          "description": "Field to throttle on. Optional.",
          "type": "string"
        },
        "throttle_secs": {
          "description": "Throttle time in seconds. The alert is triggered at most once per throttle period.",
          "format": "int32",
          "type": "integer"
        },
        "time_window_secs": {
          "description": "Lookback window used for an alert's evaluation.\nIf this is set to 86400 seconds (24 hours), only the events from the last 24 hours will be considered when the alert query is run.",
          "example": "3600",
          "format": "int32",
          "type": "integer"
        },
        "updated_at": {
          "description": "Timestamp of when the LogScaleAlert was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1LogSearchFilter": {
      "properties": {
        "query": {
          "description": "Returns logs that match this query. The query can include only top-level\noperations. Nested clauses aren't supported. Only one type of `AND` or `OR`\noperator is allowed.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MappingRule": {
      "properties": {
        "aggregation_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/MappingRuleAggregationPolicy"
            }
          ],
          "description": "Specifies how to aggregate the metric. Cannot be set if the `drop`\nparameter is set."
        },
        "bucket_slug": {
          "description": "The slug of the bucket the MappingRule belongs to.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MappingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "drop": {
          "description": "Specifies whether to drop the given set of metrics. Cannot be set if the\n`aggregation_policy` object is set.",
          "type": "boolean"
        },
        "filters": {
          "description": "The filters that determine which metrics should have rules applied to them.\nTo be considered a match, a metric must meet the criteria for all of the\nfilters specified in this array.",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "mode": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1MappingRuleMode"
            }
          ],
          "description": "The operational mode for this mapping rule. If set to `enabled`, the rule\nis applied. If set to `preview`, the rule is not applied, but shaping\nimpact statistics for the rule are recorded. Default: `enabled`."
        },
        "name": {
          "description": "The name of the MappingRule. You can modify this value after the MappingRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the MappingRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the MappingRule is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MappingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "filters",
        "name"
      ],
      "type": "object"
    },
    "configv1MappingRuleMode": {
      "description": " - ENABLED: ENABLED rules are applied. Rules default to ENABLED.\n - PREVIEW: PREVIEW rules are not applied, but shaping impact stats\nfor them rule are recorded.",
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "type": "string"
    },
    "configv1MappingRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Deprecated: This parameter is no longer supported.",
          "type": "string"
        },
        "retention": {
          "description": "Deprecated: This parameter is no longer supported.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Monitor": {
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this monitor.\nThey can be be templated with labels from notifications.",
          "type": "object"
        },
        "bucket_slug": {
          "description": "Slug of the bucket the monitor belongs to. Required if `collection_slug` isn't\nset.",
          "type": "string"
        },
        "collection": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1CollectionReference"
            }
          ],
          "description": "Collection that the monitor belongs to. Required if `bucket_slug` and\n`collection_slug` aren't set."
        },
        "collection_slug": {
          "description": "Slug of the collection the monitor belongs to. Required if `bucket_slug` isn't\nset.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the Monitor was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "graphite_query": {
          "description": "Graphite query to evaluate for the alert. If set, no other queries can be set.",
          "example": "sumSeries(stats.timers.*.mean_90)",
          "type": "string"
        },
        "interval_secs": {
          "description": "Specifies how often alerts are evaluated. Default: `60s`.",
          "format": "int32",
          "type": "integer"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Required. Labels to include in notifications generated by this monitor, and can\nbe used to route alerts with notification overrides.",
          "type": "object"
        },
        "logging_query": {
          "description": "Logging query to evaluate for the alert. If set, no other queries can be set.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Monitor. You can modify this value after the Monitor is created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Specifies the notification policy used to route alerts generated by the monitor.\nIf omitted, the notification policy is inherited from the monitor.",
          "type": "string"
        },
        "prometheus_query": {
          "description": "PromQL query to evaluate for the alert. If set, no other queries can be set.",
          "example": "up{job=\"prometheus\"} == 0",
          "type": "string"
        },
        "schedule": {
          "allOf": [
            {
              "$ref": "#/definitions/MonitorSchedule"
            }
          ],
          "description": "Defines the schedule for when the monitor should be evaluated. If not set, the\nmonitor defaults to always being active."
        },
        "series_conditions": {
          "allOf": [
            {
              "$ref": "#/definitions/MonitorSeriesConditions"
            }
          ],
          "description": "Required. Conditions to determine the severity of each series. The highest\nseverity series of a signal determines that signal's severity."
        },
        "signal_grouping": {
          "allOf": [
            {
              "$ref": "#/definitions/MonitorSignalGrouping"
            }
          ],
          "description": "Specifies the grouping of series into signals. If omitted, all series are\ngrouped into a single signal."
        },
        "slug": {
          "description": "The unique identifier of the Monitor. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Monitor is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Monitor was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1MonitorCondition": {
      "properties": {
        "op": {
          "allOf": [
            {
              "$ref": "#/definitions/ConditionOp"
            }
          ],
          "description": "Required. Specifies the comparison operator for the metric value and the configured\nvalue:\n- `GEQ`: Greater than or equal to\n- `GT`: Greater than\n- `LEQ`: Less than or equal to\n- `LT`: Less than\n- `EQ`: Equal to\n- `NEQ`: Not equal to\n- `EXISTS`: Specified value exists\n- `NOT_EXISTS`: Specified value doesn't exist"
        },
        "resolve_sustain_secs": {
          "description": "Amount of time the query needs to no longer fire before resolving. Must be an\ninteger. Accepts one of `s` (seconds), `m` (minutes), or `h` (hours) as units.",
          "format": "int32",
          "type": "integer"
        },
        "sustain_secs": {
          "description": "Amount of time the query needs to fail the condition check before an alert is\ntriggered. Must be an integer. Accepts one of `s` (seconds), `m` (minutes), or\n`h` (hours) as units.",
          "format": "int32",
          "type": "integer"
        },
        "value": {
          "description": "Required. The value to compare to the metric value using the `op` operation.",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "configv1MutingRule": {
      "properties": {
        "comment": {
          "description": "Descriptive comment that explains why the muting rule was created.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the MutingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "ends_at": {
          "description": "Required. Timestamp of when the muting rule stops being active.",
          "format": "date-time",
          "type": "string"
        },
        "label_matchers": {
          "description": "Required. Specifies which series are silenced by the muting rule. Alerting\nseries must match all muting rule matchers to be silenced. You can't update this\nvalue. Updates must specify the original value.",
          "items": {
            "$ref": "#/definitions/configv1MutingRuleLabelMatcher"
          },
          "type": "array"
        },
        "name": {
          "description": "The name of the MutingRule. You can modify this value after the MutingRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the MutingRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the MutingRule is created.",
          "type": "string"
        },
        "starts_at": {
          "description": "Required. Timestamp of when the muting rule becomes active. You can't update\nthis value. Updates must specify the original value.",
          "format": "date-time",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the MutingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1MutingRuleLabelMatcher": {
      "properties": {
        "name": {
          "description": "Required. Always matches against an exact label name.",
          "type": "string"
        },
        "type": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1MutingRuleLabelMatcherMatcherType"
            }
          ],
          "description": "Required. Determines how the label value is matched."
        },
        "value": {
          "description": "Required. Matches against a label value based on the configured type.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1MutingRuleLabelMatcherMatcherType": {
      "enum": [
        "EXACT",
        "REGEX",
        "NOT_EXACT",
        "NOT_REGEXP"
      ],
      "type": "string"
    },
    "configv1NotificationPolicy": {
      "properties": {
        "bucket_slug": {
          "description": "The slug of the bucket that the notification policy belongs to. Required if\n`team_slug` is not set.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the NotificationPolicy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "name": {
          "description": "The name of the NotificationPolicy. You can modify this value after the NotificationPolicy is created.",
          "type": "string"
        },
        "routes": {
          "allOf": [
            {
              "$ref": "#/definitions/NotificationPolicyRoutes"
            }
          ],
          "description": "The routing configuration for alerts that use this notification policy."
        },
        "slug": {
          "description": "The unique identifier of the NotificationPolicy. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the NotificationPolicy is created.",
          "type": "string"
        },
        "team_slug": {
          "description": "The slug of the team that the notification policy belongs to. Required if\n`bucket_slug` is not set.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the NotificationPolicy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1Notifier": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the Notifier was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "discard": {
          "description": "If `true`, enables the `discard` integration, which discards all\nnotifications. Cannot be set if another integration is set.",
          "type": "boolean"
        },
        "email": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierEmailConfig"
            }
          ],
          "description": "If an object is specified, sends notifications through an email integration.\nCannot be set if another integration is set."
        },
        "name": {
          "description": "The name of the Notifier. You can modify this value after the Notifier is created.",
          "type": "string"
        },
        "ops_genie": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierOpsGenieConfig"
            }
          ],
          "description": "If an object is specified, sends notifications through an Opsgenie integration.\nCannot be set if another integration is set."
        },
        "pagerduty": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierPagerdutyConfig"
            }
          ],
          "description": "If an object is specified, sends notifications through a PagerDuty integration.\nCannot be set if another integration is set."
        },
        "skip_resolved": {
          "description": "If `true`, disables notifications for resolved alerts. Cannot be set if\n`discard` equals `true`.",
          "type": "boolean"
        },
        "slack": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierSlackConfig"
            }
          ],
          "description": "If an object is specified, sends notifications through a Slack integration.\nCannot be set if another integration is set."
        },
        "slug": {
          "description": "The unique identifier of the Notifier. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Notifier is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Notifier was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "victor_ops": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierVictorOpsConfig"
            }
          ],
          "description": "If an object is specified, sends notifications through a VictorOps integration.\nCannot be set if another integration is set."
        },
        "webhook": {
          "allOf": [
            {
              "$ref": "#/definitions/NotifierWebhookConfig"
            }
          ],
          "description": "If an object is specified, sends notifications through a webhook integration.\nCannot be set if another integration is set."
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1OtelMetricsIngestion": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "resource_attributes": {
          "allOf": [
            {
              "$ref": "#/definitions/OtelMetricsIngestionResourceAttributes"
            }
          ],
          "description": "Specifies how to ingest OpenTelemetry resource attributes. These attributes\nhave no direct equivalent in the internal data model of Chronosphere\nObservability Platform."
        },
        "updated_at": {
          "description": "Timestamp of when the OtelMetricsIngestion was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageParams": {
      "properties": {
        "max_size": {
          "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
          "format": "int64",
          "type": "integer"
        },
        "token": {
          "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1PageResult": {
      "properties": {
        "next_token": {
          "description": "An opaque page token that identifies the next page of items that the\nclient should request. An empty value indicates that there are no\nmore items to return.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ReadAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1ReadBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1ReadClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1ReadConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configv1ReadConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1ReadDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1ReadDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1ReadGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "$ref": "#/definitions/configv1GcpMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1ReadGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1ReadLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1ReadLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1ReadMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1ReadMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1ReadNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1ReadOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1ReadRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1ReadResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1ReadRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1ReadSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceAccountResponse": {
      "properties": {
        "service_account": {
          "$ref": "#/definitions/configv1ServiceAccount"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceAttributeResponse": {
      "properties": {
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        },
        "service_slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1ReadServiceResponse": {
      "properties": {
        "service": {
          "$ref": "#/definitions/configv1Service"
        }
      },
      "type": "object"
    },
    "configv1ReadTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1ReadTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "configv1RecordingRule": {
      "properties": {
        "bucket_slug": {
          "description": "The slug of the bucket the recording rule belongs to. Required if\n`execution_group` is not set. If both `bucket_slug` and `execution_group`\nare set, their values must match.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RecordingRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "execution_group": {
          "description": "The slug of the execution group in which the recording rule will be\nevaluated. Required if `bucket_slug` is not set.  If both `bucket_slug` and\n`execution_group` are set, their values must match.",
          "type": "string"
        },
        "interval_secs": {
          "description": "Specifies how often to evaluate the recording rule.",
          "format": "int32",
          "type": "integer"
        },
        "label_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RecordingRuleLabelPolicy"
            }
          ],
          "description": "The label policy for the recording rule."
        },
        "metric_name": {
          "description": "The name of the time series to use for the output of `prometheus_expr`.\nThis value must be a valid metric name. If you don't set this value,\nthe output of `prometheus_expr` is output to a time series with a name\ndefined by the value of `name`.",
          "type": "string"
        },
        "name": {
          "description": "The name of the RecordingRule. You can modify this value after the RecordingRule is created.",
          "type": "string"
        },
        "prometheus_expr": {
          "description": "The PromQL expression to evaluate at the time of each evaluation cycle. The\nresult is output to a new time series with a name defined by the value of\n`metric_name`. If `metric_name` is unset, the result is output to a\ntime series defined by the value of `name`.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the RecordingRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the RecordingRule is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the RecordingRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1RecordingRuleLabelPolicy": {
      "properties": {
        "add": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "A list of labels to add or overwrite before storing the result.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "configv1ResourcePools": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ResourcePools was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_pool": {
          "allOf": [
            {
              "$ref": "#/definitions/ResourcePoolsDefaultPool"
            }
          ],
          "description": "Defines the default pool. Metrics that don't match any of the configured pools\nmap to the default pool."
        },
        "pools": {
          "description": "Optional. Defines additional pools, which can't exceed 20 pools.",
          "items": {
            "$ref": "#/definitions/ResourcePoolsPool"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the ResourcePools was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "default_pool"
      ],
      "type": "object"
    },
    "configv1ResourcePoolsAllocation": {
      "properties": {
        "fixed_values": {
          "description": "Optional. Specifies overrides for the `percent_of_license` allocations for\nspecified licenses. When defining fixed values for a license, all pools must\nhave an explicit fixed value specification for that given license. The default\npool receives all remaining quota left within the license, after subtracting\nthe sum of fixed values across pools for that license.",
          "items": {
            "$ref": "#/definitions/AllocationFixedValue"
          },
          "type": "array"
        },
        "percent_of_license": {
          "description": "Percent of the license to allocate to this pool. This value must be between\n`0` and `100`, inclusive. The `percent_of_license` values across all pools,\nexcluding the default pool, must be less than or equal to 100. The\n`default_pool` receives any remaining allocation, so you don't need to specify\na value for it explicitly. If you specify an allocation for the\n`default_pool`, the sum of `percent_of_license` across all pools (including\nthe default pool) must exactly equal `100`.",
          "format": "double",
          "type": "number"
        },
        "priority_thresholds": {
          "description": "Defines thresholds with strict limits for when to drop new consumption of the\npersisted cardinality license for a pool. Setting `priority_thresholds` is\nrequired to set limits for cardinality licenses. Only\n`PERSISTED_CARDINALITY_STANDARD` and `PERSISTED_CARDINALITY_HISTOGRAM` are\nsupported.",
          "items": {
            "$ref": "#/definitions/AllocationThresholds"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1ResourceType": {
      "enum": [
        "BUCKET",
        "DASHBOARD",
        "GRAFANA_DASHBOARD",
        "MONITOR",
        "NOTIFICATION_POLICY",
        "RECORDING_RULE",
        "MAPPING_RULE",
        "ROLLUP_RULE"
      ],
      "type": "string"
    },
    "configv1RollupRule": {
      "properties": {
        "add_metric_type_label": {
          "description": "Defines whether to add a `__rollup_type__` label in the new metric.",
          "type": "boolean"
        },
        "aggregation": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1AggregationType"
            }
          ],
          "description": "Defines the method by which metrics are aggregated."
        },
        "bucket_slug": {
          "description": "The slug of the bucket the RollupRule belongs to.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the RollupRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "drop_raw": {
          "description": "Defines whether to automatically generate drop rules for this rollup rule. Set\nto `true` to remove raw metrics that match this rollup rule. Default: `false`.",
          "type": "boolean"
        },
        "expansive_match": {
          "description": "**DEPRECATED**.\nA series matches and aggregates only if each label defined by filters and\n`label_policy.keep` or `graphite_label_policy.replace` (respectively) exist in\nthe series. Setting `expansive_match=true` removes this restriction. Default:\n`expansive_match=false`.\n\nIf `false`, a series matches and aggregates only if each label defined by the\nprovided `filters` and the `label_policy.keep` or\n`graphite_label_policy.replace` settings exist in the series.",
          "type": "boolean"
        },
        "filters": {
          "description": "Filters incoming metrics by label. If multiple label filters are specified, an\nincoming metric must match every label filter to match the rule. Label values\nsupport glob patterns, including matching multiple patterns with an `OR`, such\nas `service:{svc1,svc2}`. These special filters are available for matching\nmetrics by non-label request metadata:\n * `__metric_type__`: Matches the incoming metric's [Observability Platform\n   metric\n   type](https://docs.chronosphere.io/control/shaping/types#observability-platform-types).\n   This is the recommended method for filtering on metric type. Valid values:\n   `cumulative_counter`, `cumulative_exponential_histogram`, `delta_counter`,\n   `delta_exponential_histogram`, `gauge`, `measurement`.\n * `__metric_source__`: Matches the incoming metric's [source\n   format](https://docs.chronosphere.io/control/shaping/types#supported-formats).\n   Valid values: `carbon`, `chrono_gcp`, `dogstatsd`, `open_metrics`,\n   `open_telemetry`, `prometheus`, `signalfx`, `statsd`, `wavefront`.\n * `__m3_prom_type__`: When ingesting metric data with Prometheus, matches the\n   incoming metric's [Prometheus metric\n   type](https://docs.chronosphere.io/control/shaping/types#prometheus). Valid\n   values: `counter`, `gauge`, `histogram`, `gauge_histogram`, `summary`,\n   `info`, `state_set`, `quantile`.\n * `__otel_type__`: When ingesting with OpenTelemetry, matches on the incoming\n   metric's [OpenTelemetry metric\n   type](https://docs.chronosphere.io/control/shaping/types#opentelemetry).\n   Valid values: `sum`, `monotonic_sum`, `gauge`, `histogram`, `exp_histogram`,\n  `summary`. For example, the following filter matches any cumulative counter\n  metric with a `service=gateway` label whose metric name starts with\n  `http_requests_`:\n```\n__metric_type__:cumulative_counter service:gateway __name__:http_requests_*\n```",
          "items": {
            "$ref": "#/definitions/configv1LabelFilter"
          },
          "type": "array"
        },
        "graphite_label_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/RollupRuleGraphiteLabelPolicy"
            }
          ],
          "description": "Optional. Label aggregation policy for Graphite metrics. If set, new\nrestrictions will apply to the rule:\n- `label_policy` cannot be set.\n- `metric_name` cannot be set.\n- `filters` can reference only positional Graphite labels, such as `__gX__`,\n  and synthetic labels, such as `__metric_type__`."
        },
        "interval": {
          "description": "Optional. Sets a custom interval that defines the amount of\ntime between aggregated data points. Intervals are based on your\n[retention policy](https://docs.chronosphere.io/administer/licensing#retention-policies).\nThis field was known as `storage_policies` in version\n0.286.0-2023-01-06-release.1\nand earlier.",
          "type": "string"
        },
        "label_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RollupRuleLabelPolicy"
            }
          ],
          "description": "Label aggregation policy, which acts as a filter, defining which labels to\npreserve in the resulting metric. Use `keep` to keep one or more labels, or\n`discard` to ignore one or more labels. Required for non-Graphite rules."
        },
        "label_replace": {
          "allOf": [
            {
              "$ref": "#/definitions/RollupRuleLabelReplace"
            }
          ],
          "description": "**DEPRECATED**."
        },
        "metric_name": {
          "description": "The name of the new metric to create and persist to the database. You can use\nthe template string `{{.MetricName }}` to create a new metric name that\nreferences the original metric name. For example, `new_metric: '{{ .MetricName\n}}:by_instance'` outputs a metric with the name `my_metric:by_instance` if the\nmatched metric is `my_metric`.\nThis field is optional for Graphite rollup rules.",
          "type": "string"
        },
        "metric_type": {
          "allOf": [
            {
              "$ref": "#/definitions/RollupRuleMetricType"
            }
          ],
          "description": "Declares the metric type of the input metrics. Each rollup rule must declare the\ntype of metric it aggregates by setting the `metric_type` field, because each\nmetric type aggregates differently. Choosing the wrong `metric_type` for your\nrule can produce unexpected results.\n\n`COUNTER` is deprecated; use `CUMULATIVE_COUNTER` instead.\n\n`DELTA` is deprecated; use `DELTA_COUNTER` instead."
        },
        "mode": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RollupRuleMode"
            }
          ],
          "description": "The operational mode for this rollup rule. If `mode=ENABLED`, the rule is\napplied. If `mode=PREVIEW`, the rule is not applied, but shaping impact stats\nfor the rule are recorded. If empty, defaults to `mode=ENABLED`."
        },
        "name": {
          "description": "The name of the RollupRule. You can modify this value after the RollupRule is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the RollupRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the RollupRule is created.",
          "type": "string"
        },
        "storage_policy": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1RollupRuleStoragePolicy"
            }
          ],
          "description": "**DEPRECATED**.\nUse `interval` instead. Storage policy applied to the resulting\nrollup rule, which must match a known storage policy. If empty, the default\nstorage policy is used. If set, `interval` can't be set."
        },
        "updated_at": {
          "description": "Timestamp of when the RollupRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "bucket_slug",
        "name"
      ],
      "type": "object"
    },
    "configv1RollupRuleLabelPolicy": {
      "description": "TODO: consolidate w/ RecordingRule.LabelPolicy once both of these\n entities implement the same label semantics.",
      "properties": {
        "discard": {
          "description": "Labels to discard in the output metric. If set, the `keep` field must be\nempty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "keep": {
          "description": "Labels to retain in the output metric. If set, the `discard` field must\nbe empty.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "configv1RollupRuleMode": {
      "enum": [
        "ENABLED",
        "PREVIEW"
      ],
      "title": "- PREVIEW: TODO: DISABLED = 2;",
      "type": "string"
    },
    "configv1RollupRuleStoragePolicy": {
      "properties": {
        "resolution": {
          "description": "Resolution of the aggregated metrics.",
          "type": "string"
        },
        "retention": {
          "description": "Retention of the aggregated metrics.",
          "type": "string"
        }
      },
      "required": [
        "resolution",
        "retention"
      ],
      "type": "object"
    },
    "configv1SLI": {
      "properties": {
        "additional_promql_filters": {
          "description": "Specifies additional PromQL filters, which are made available to the SLO queries.\nUse these filters to reduce the number of metrics used by the SLO.",
          "example": "cluster!~\"dev\"",
          "items": {
            "$ref": "#/definitions/commonPromQLMatcher"
          },
          "type": "array"
        },
        "custom_dimension_labels": {
          "description": "Configures additional labels to export from the underlying queries. This feature\nprovides a logical budget to group unique combinations of dimensions. For\nexample, if you want to track a budget per endpoint, add the endpoint label as a\ndimension. These dimensions are provided on the top-level SLI so that SLOs will\nreceive them in the `.GroupBy` variable.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "custom_indicator": {
          "allOf": [
            {
              "$ref": "#/definitions/SLICustomIndicatorConfig"
            }
          ],
          "description": "Indicates an error ratio SLI, which measures a count of events matching some\ncondition against a total number of events. For example, measuring a ratio of\nsuccessful requests against the total number of requests. Use `custom_indicator`\nto track error ratio SLOs. You can set only one of `custom_indicator` or\n`custom_timeslice_indicator`."
        },
        "custom_timeslice_indicator": {
          "allOf": [
            {
              "$ref": "#/definitions/SLICustomTimeSliceIndicatorConfig"
            }
          ],
          "description": "Indicates a TimeSlice SLI, which measures a count of time slices that meet a\ndefined condition, compared against the total number of time slices in a\nspecific time period. Use `custom_timeslice_indicator` to track TimeSlice SLOs.\nYou can set only one of `custom_indicator` or `custom_timeslice_indicator`."
        }
      },
      "type": "object"
    },
    "configv1SLO": {
      "properties": {
        "annotations": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations are visible in notifications generated by this SLO.\nYou can template annotations with labels from notifications.",
          "type": "object"
        },
        "collection_ref": {
          "$ref": "#/definitions/configv1CollectionReference"
        },
        "created_at": {
          "description": "Timestamp of when the SLO was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "definition": {
          "allOf": [
            {
              "$ref": "#/definitions/SLODefinition"
            }
          ],
          "description": "Defines the core criteria the SLO measures."
        },
        "description": {
          "type": "string"
        },
        "labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are visible in notifications generated by this SLO,\nand can be used to route alerts with notification overrides.",
          "type": "object"
        },
        "name": {
          "description": "The name of the SLO. You can modify this value after the SLO is created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Optional. Slug of the notification policy to use for the SLO. If you don't\nspecify a value, then the collection or service this SLO belongs to must have a\nnotification policy. Required if alerting is enabled for this SLO.",
          "example": "alerting_notification_policy",
          "type": "string"
        },
        "signal_grouping": {
          "$ref": "#/definitions/MonitorSignalGrouping"
        },
        "sli": {
          "$ref": "#/definitions/configv1SLI"
        },
        "slug": {
          "description": "The unique identifier of the SLO. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the SLO is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the SLO was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1Service": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the Service was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional. Description of the service collection.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Service. You can modify this value after the Service is created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "Slug of the notification policy used by default for monitors in this service\ncollection. This parameter is optional if the collection doesn't contain\nmonitors, or if all of its monitors explicitly reference a policy. This\nparameter doesn't override the policy used if a monitor explicitly references\na policy.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Service. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Service is created.",
          "type": "string"
        },
        "team_slug": {
          "description": "Slug of the team the service collection belongs to.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Service was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name",
        "team_slug"
      ],
      "type": "object"
    },
    "configv1ServiceAccount": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the ServiceAccount was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "email": {
          "description": "The unique email user for this service account. Cannot be set by clients.",
          "readOnly": true,
          "type": "string"
        },
        "metrics_restriction": {
          "allOf": [
            {
              "$ref": "#/definitions/ServiceAccountMetricsRestriction"
            }
          ],
          "description": "If set, restricts access of the service account to only metric data.\n\nOnly one of `unrestricted` or `metrics_restriction` must be set."
        },
        "name": {
          "description": "The name of the ServiceAccount. You can modify this value after the ServiceAccount is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the ServiceAccount. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the ServiceAccount is created.",
          "type": "string"
        },
        "token": {
          "description": "Generated API token of the service account. Cannot be set by clients.\n\nThe token is set only once by the server in the `CreateServiceAccount` response.\nThe `ReadServiceAccount` response always returns an empty token. Therefore, when\ncreating a service account, ensure you securely store the response token.\nIf you lose the token, you must delete and recreate the service account to\ngenerate a new token.",
          "readOnly": true,
          "type": "string"
        },
        "unrestricted": {
          "description": "If set, grants the service account access to all Chronosphere APIs, including\nresource configuration and metric data within the access controls defined by the\nservice account's team membership.\n\nOnly one of `unrestricted` or `metrics_restriction` must be set.",
          "type": "boolean"
        },
        "updated_at": {
          "description": "Timestamp of when the ServiceAccount was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1ServiceAttribute": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the service attributes were created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "A description of the service.",
          "type": "string"
        },
        "name": {
          "description": "The name of the service. You can modify this value after the service\nattributes are created.",
          "type": "string"
        },
        "notification_policy_slug": {
          "description": "The slug of the notification policy for the associated service.",
          "type": "string"
        },
        "service_slug": {
          "description": "The slug of the service.",
          "type": "string"
        },
        "team_slug": {
          "description": "The slug of the team that the associated service belongs to.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the service attributes were updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1Team": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the Team was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "description": "Optional. Short description of the team.",
          "type": "string"
        },
        "name": {
          "description": "The name of the Team. You can modify this value after the Team is created.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the Team. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the Team is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the Team was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "user_emails": {
          "description": "Unordered set of emails whose users are members of this team.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1TraceBehavior": {
      "properties": {
        "base_head_sample_rate": {
          "description": "Specifies the sample rate for head sampling. This rate applies to all root spans\nthat are enrolled in head sampling, but don't have a specific rule defined for\ntheir service.",
          "format": "double",
          "type": "number"
        },
        "base_tail_sample_rate": {
          "description": "Specifies the base sample rate for fully assembled traces that don't apply to\nthe `error_sample_options`, `fast_sample_options`, `slow_sample_options`,\n`large_trace_sample_options`, or `small_trace_sample_options` sampling options.",
          "format": "double",
          "type": "number"
        },
        "created_at": {
          "description": "Timestamp of when the TraceBehavior was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "error_sample_options": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorErrorSampleOptions"
            }
          ],
          "description": "Optional. Specifies sampling options for traces whose root span is an error."
        },
        "fast_sample_options": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorFastSampleOptions"
            }
          ],
          "description": "Optional. Specifies sampling options for traces whose root span duration is less\nthan the specified threshold."
        },
        "large_trace_sample_options": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorLargeTraceSampleOptions"
            }
          ],
          "description": "Optional. Specifies sampling options for traces with spans greater than or equal\nto the specified threshold."
        },
        "name": {
          "description": "The name of the TraceBehavior. You can modify this value after the TraceBehavior is created.",
          "type": "string"
        },
        "slow_sample_options": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorSlowSampleOptions"
            }
          ],
          "description": "Optional. Specifies sampling options for traces whose root span duration is\ngreater than the specified threshold."
        },
        "slug": {
          "description": "The unique identifier of the TraceBehavior. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the TraceBehavior is created.",
          "type": "string"
        },
        "small_trace_sample_options": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceBehaviorSmallTraceSampleOptions"
            }
          ],
          "description": "Optional. Specifies sampling options for traces with spans less than or equal to\nthe specified threshold."
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehavior was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1TraceBehaviorConfig": {
      "description": "TraceBehaviorConfig is a singleton configuration object that specifies the\nconfiguration for trace behaviors.",
      "properties": {
        "baseline_behavior_slug": {
          "description": "The baseline behavior to use for behavior assignments and base head sampling rates.",
          "type": "string"
        },
        "created_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "dataset_priorities": {
          "description": "List of dataset priorities. This list specifies the order in which datasets are\nconsidered when determining the behavior to follow for a trace. Dataset\npriorities are used to break ties when a trace matches more than one dataset\nwith an active behavior.\n* Each entry in this list must refer to the slug of an existing dataset.\n* The order of the list is the order in which the datasets are considered.\n* The list must contain all datasets referenced in either\n  `main_behavior_assignments` or `override_behavior_assignments`.\n* The list can contain datasets that are not referenced in either of these\n  assignments.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "main_behavior_assignments": {
          "description": "List of assignments for the main behavior. The referenced datasets will be\nenrolled in behaviors. The referenced behaviors are the active behaviors for the\ndataset when there is no active override. Only one main behavior can be assigned\nto a dataset. See the documentation for\n[customizing your sampling\nstrategy](https://docs.chronosphere.io/control/sampling/behaviors#customize-your-sampling-strategy)\nfor more information.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigMainBehaviorAssignment"
          },
          "type": "array"
        },
        "override_behavior_assignments": {
          "description": "List of assignments for the override behavior. These assignments specify the\nactive behavior for a dataset over a specific time range. Only one override\nbehavior can be assigned to a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        },
        "preview_behavior_assignments": {
          "description": "List of assignments for the preview behavior. The referenced behaviors are in\npreview mode for the assigned dataset. You can assign only one preview behavior\nto a dataset.",
          "items": {
            "$ref": "#/definitions/TraceBehaviorConfigOverrideBehaviorAssignment"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceBehaviorConfig was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceDataset": {
      "properties": {
        "match_criteria": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceSearchFilter"
            }
          ],
          "description": "Required. Defines the criteria to match traces to a dataset."
        }
      },
      "type": "object"
    },
    "configv1TraceJaegerRemoteSamplingStrategy": {
      "properties": {
        "applied_strategy": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceJaegerRemoteSamplingStrategyAppliedStrategy"
            }
          ],
          "description": "The strategy to apply for JaegerRemoteSampler-enabled agents running in the\nnamed service. Exactly one of the following strategies must be set. See the\nObservability Platform documentation for\n[Creating head sampling rules](https://docs.chronosphere.io/control/sampling/head-sampling#create-head-sampling-rules)\nfor more information."
        },
        "created_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "name": {
          "description": "The name of the TraceJaegerRemoteSamplingStrategy. You can modify this value after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "service_name": {
          "description": "The name of the service this sampling strategy applies to. This value must match\nthe `slug` and `name` fields.",
          "type": "string"
        },
        "slug": {
          "description": "The unique identifier of the TraceJaegerRemoteSamplingStrategy. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the TraceJaegerRemoteSamplingStrategy is created.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the TraceJaegerRemoteSamplingStrategy was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1TraceMetricsRule": {
      "properties": {
        "created_at": {
          "description": "Timestamp of when the TraceMetricsRule was created. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "group_by": {
          "description": "Add labels to the resultant metrics based on the specified key:value pairs.",
          "items": {
            "$ref": "#/definitions/configv1TraceMetricsRuleGroupBy"
          },
          "type": "array"
        },
        "histogram_buckets_secs": {
          "description": "Histogram bucket values, in seconds, for generated duration metrics.",
          "items": {
            "format": "double",
            "type": "number"
          },
          "type": "array"
        },
        "metric_labels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels to apply to the generated trace metrics.",
          "type": "object"
        },
        "metric_name": {
          "description": "The name of the generated trace metrics.",
          "type": "string"
        },
        "name": {
          "description": "The name of the TraceMetricsRule. You can modify this value after the TraceMetricsRule is created.",
          "type": "string"
        },
        "scope_filter": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterScopeFilter"
            }
          ],
          "description": "Scope filter to determine which spans should be counted for metrics generation.\nOnly spans matching the scope filter will contribute to trace metrics."
        },
        "slug": {
          "description": "The unique identifier of the TraceMetricsRule. If a `slug` isn't provided, one is generated based on the `name` field. You can't modify this field after the TraceMetricsRule is created.",
          "type": "string"
        },
        "trace_filter": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceSearchFilter"
            }
          ],
          "description": "Filter that defines traces that should yield the defined metrics."
        },
        "updated_at": {
          "description": "Timestamp of when the TraceMetricsRule was last updated. Cannot be set by clients.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "configv1TraceMetricsRuleGroupBy": {
      "description": "GroupBy contains fields required to group the resultant metrics of a TraceMetricsRule by a specific key.",
      "properties": {
        "key": {
          "allOf": [
            {
              "$ref": "#/definitions/GroupByGroupByKey"
            }
          ],
          "description": "The key to group by."
        },
        "label": {
          "description": "The label to use in the resulting metrics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceSearchFilter": {
      "properties": {
        "scope_filter": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterScopeFilter"
            }
          ],
          "description": "Scope filter that defines which spans within matching traces contribute to metrics calculation."
        },
        "span": {
          "description": "Specifies the span conditions to match on. All conditions must be true in a\nsingle span for the span to be considered a match. If `span_count` is specified,\nthe number of spans within the trace that match span conditions must be within\n`[min, max]`. You can specify multiple span conditions, and each can be\nsatisfied by any number of spans within the trace.",
          "items": {
            "$ref": "#/definitions/TraceSearchFilterSpanFilter"
          },
          "type": "array"
        },
        "trace": {
          "allOf": [
            {
              "$ref": "#/definitions/TraceSearchFilterTraceFilter"
            }
          ],
          "description": "Trace-level filter criteria (effectively matching the root span)."
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRule": {
      "description": "Contains configuration for one tail sampling rule.",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the rule was created.",
          "format": "date-time",
          "type": "string"
        },
        "filter": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceSearchFilter"
            }
          ],
          "description": "Filter criteria applied to each trace to determine whether the trace is a match."
        },
        "name": {
          "description": "A human-readable name of the rule.",
          "type": "string"
        },
        "sample_rate": {
          "description": "Specifies the percentage of traces to keep, which must be a number between `0`\nand `1`, inclusive, where `1` equates to 100 percent.",
          "format": "double",
          "type": "number"
        },
        "system_name": {
          "description": "Name used as the metric label value for metrics that are emitted from this rule.",
          "type": "string"
        },
        "updated_at": {
          "description": "Timestamp of when the rule was updated.",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1TraceTailSamplingRules": {
      "description": "Root object containing all tail sampling rules (for a tenant).",
      "properties": {
        "created_at": {
          "description": "Timestamp of when the rule was created.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        },
        "default_sample_rate": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1DefaultSampleRate"
            }
          ],
          "description": "Optional. By default, all traces not matching the defined rules are kept. You\ncan override this behavior by providing a default sample rate."
        },
        "rules": {
          "description": "Optional. Specifies a list of rules and a sampling rate to apply. Rules are\nevaluated in order until a match is found. If no sample rate is specified, the\ndefault sample rate is applied.",
          "items": {
            "$ref": "#/definitions/configv1TraceTailSamplingRule"
          },
          "type": "array"
        },
        "updated_at": {
          "description": "Timestamp of when the rule was updated.",
          "format": "date-time",
          "readOnly": true,
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1UpdateAzureMetricsIntegrationResponse": {
      "properties": {
        "azure_metrics_integration": {
          "$ref": "#/definitions/configv1AzureMetricsIntegration"
        }
      },
      "type": "object"
    },
    "configv1UpdateBucketResponse": {
      "properties": {
        "bucket": {
          "$ref": "#/definitions/configv1Bucket"
        }
      },
      "type": "object"
    },
    "configv1UpdateClassicDashboardResponse": {
      "properties": {
        "classic_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateCollectionResponse": {
      "properties": {
        "collection": {
          "$ref": "#/definitions/configv1Collection"
        }
      },
      "type": "object"
    },
    "configv1UpdateConsumptionBudgetResponse": {
      "properties": {
        "consumption_budget": {
          "$ref": "#/definitions/configv1ConsumptionBudget"
        }
      },
      "type": "object"
    },
    "configv1UpdateConsumptionConfigRequest": {
      "properties": {
        "consumption_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ConsumptionConfig"
            }
          ],
          "description": "The ConsumptionConfig to update."
        },
        "create_if_missing": {
          "description": "If `true`, the ConsumptionConfig will be created if it does not already exist. If `false`, an error will be returned if the ConsumptionConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the ConsumptionConfig. If the specified configuration is valid, the endpoint returns a partial response without the ConsumptionConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "configv1UpdateConsumptionConfigResponse": {
      "properties": {
        "consumption_config": {
          "$ref": "#/definitions/configv1ConsumptionConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateDashboardResponse": {
      "properties": {
        "dashboard": {
          "$ref": "#/definitions/configv1Dashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateDatasetResponse": {
      "properties": {
        "dataset": {
          "$ref": "#/definitions/configv1Dataset"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedLabelResponse": {
      "properties": {
        "derived_label": {
          "$ref": "#/definitions/configv1DerivedLabel"
        }
      },
      "type": "object"
    },
    "configv1UpdateDerivedMetricResponse": {
      "properties": {
        "derived_metric": {
          "$ref": "#/definitions/configv1DerivedMetric"
        }
      },
      "type": "object"
    },
    "configv1UpdateDropRuleResponse": {
      "properties": {
        "drop_rule": {
          "$ref": "#/definitions/configv1DropRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateGcpMetricsIntegrationResponse": {
      "properties": {
        "gcp_metrics_integration": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1GcpMetricsIntegration"
            }
          ],
          "description": "The updated GcpMetricsIntegration."
        }
      },
      "type": "object"
    },
    "configv1UpdateGrafanaDashboardResponse": {
      "properties": {
        "grafana_dashboard": {
          "$ref": "#/definitions/configv1GrafanaDashboard"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the LogAllocationConfig will be created if it does not already exist. If `false`, an error will be returned if the LogAllocationConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogAllocationConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogAllocationConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_allocation_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogAllocationConfig"
            }
          ],
          "description": "The LogAllocationConfig to update."
        }
      },
      "type": "object"
    },
    "configv1UpdateLogAllocationConfigResponse": {
      "properties": {
        "log_allocation_config": {
          "$ref": "#/definitions/configv1LogAllocationConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogControlConfigRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the LogControlConfig will be created if it does not already exist. If `false`, an error will be returned if the LogControlConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogControlConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogControlConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_control_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogControlConfig"
            }
          ],
          "description": "The LogControlConfig to update."
        }
      },
      "type": "object"
    },
    "configv1UpdateLogControlConfigResponse": {
      "properties": {
        "log_control_config": {
          "$ref": "#/definitions/configv1LogControlConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogIngestConfigRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the LogIngestConfig will be created if it does not already exist. If `false`, an error will be returned if the LogIngestConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the LogIngestConfig. If the specified configuration is valid, the endpoint returns a partial response without the LogIngestConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "log_ingest_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1LogIngestConfig"
            }
          ],
          "description": "The LogIngestConfig to update."
        }
      },
      "type": "object"
    },
    "configv1UpdateLogIngestConfigResponse": {
      "properties": {
        "log_ingest_config": {
          "$ref": "#/definitions/configv1LogIngestConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleActionResponse": {
      "properties": {
        "log_scale_action": {
          "$ref": "#/definitions/configv1LogScaleAction"
        }
      },
      "type": "object"
    },
    "configv1UpdateLogScaleAlertResponse": {
      "properties": {
        "log_scale_alert": {
          "$ref": "#/definitions/configv1LogScaleAlert"
        }
      },
      "type": "object"
    },
    "configv1UpdateMappingRuleResponse": {
      "properties": {
        "mapping_rule": {
          "$ref": "#/definitions/configv1MappingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateMonitorResponse": {
      "properties": {
        "monitor": {
          "$ref": "#/definitions/configv1Monitor"
        }
      },
      "type": "object"
    },
    "configv1UpdateMutingRuleResponse": {
      "properties": {
        "muting_rule": {
          "$ref": "#/definitions/configv1MutingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotificationPolicyResponse": {
      "properties": {
        "notification_policy": {
          "$ref": "#/definitions/configv1NotificationPolicy"
        }
      },
      "type": "object"
    },
    "configv1UpdateNotifierResponse": {
      "properties": {
        "notifier": {
          "$ref": "#/definitions/configv1Notifier"
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the OtelMetricsIngestion will be created if it does not already exist. If `false`, an error will be returned if the OtelMetricsIngestion does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the OtelMetricsIngestion. If the specified configuration is valid, the endpoint returns a partial response without the OtelMetricsIngestion. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "otel_metrics_ingestion": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1OtelMetricsIngestion"
            }
          ],
          "description": "The OtelMetricsIngestion to update."
        }
      },
      "type": "object"
    },
    "configv1UpdateOtelMetricsIngestionResponse": {
      "properties": {
        "otel_metrics_ingestion": {
          "$ref": "#/definitions/configv1OtelMetricsIngestion"
        }
      },
      "type": "object"
    },
    "configv1UpdateRecordingRuleResponse": {
      "properties": {
        "recording_rule": {
          "$ref": "#/definitions/configv1RecordingRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the ResourcePools will be created if it does not already exist. If `false`, an error will be returned if the ResourcePools does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the ResourcePools. If the specified configuration is valid, the endpoint returns a partial response without the ResourcePools. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "resource_pools": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1ResourcePools"
            }
          ],
          "description": "The ResourcePools to update."
        }
      },
      "type": "object"
    },
    "configv1UpdateResourcePoolsResponse": {
      "properties": {
        "resource_pools": {
          "$ref": "#/definitions/configv1ResourcePools"
        }
      },
      "type": "object"
    },
    "configv1UpdateRollupRuleResponse": {
      "properties": {
        "rollup_rule": {
          "$ref": "#/definitions/configv1RollupRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateSLOResponse": {
      "properties": {
        "slo": {
          "$ref": "#/definitions/configv1SLO"
        }
      },
      "type": "object"
    },
    "configv1UpdateServiceAttributeResponse": {
      "properties": {
        "service_attribute": {
          "$ref": "#/definitions/configv1ServiceAttribute"
        },
        "service_slug": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "configv1UpdateTeamResponse": {
      "properties": {
        "team": {
          "$ref": "#/definitions/configv1Team"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceBehaviorConfig will be created if it does not already exist. If `false`, an error will be returned if the TraceBehaviorConfig does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceBehaviorConfig. If the specified configuration is valid, the endpoint returns a partial response without the TraceBehaviorConfig. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_behavior_config": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceBehaviorConfig"
            }
          ],
          "description": "The TraceBehaviorConfig to update."
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorConfigResponse": {
      "properties": {
        "trace_behavior_config": {
          "$ref": "#/definitions/configv1TraceBehaviorConfig"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceBehaviorResponse": {
      "properties": {
        "trace_behavior": {
          "$ref": "#/definitions/configv1TraceBehavior"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceJaegerRemoteSamplingStrategyResponse": {
      "properties": {
        "trace_jaeger_remote_sampling_strategy": {
          "$ref": "#/definitions/configv1TraceJaegerRemoteSamplingStrategy"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceMetricsRuleResponse": {
      "properties": {
        "trace_metrics_rule": {
          "$ref": "#/definitions/configv1TraceMetricsRule"
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesRequest": {
      "properties": {
        "create_if_missing": {
          "description": "If `true`, the TraceTailSamplingRules will be created if it does not already exist. If `false`, an error will be returned if the TraceTailSamplingRules does not already exist.",
          "type": "boolean"
        },
        "dry_run": {
          "description": "If `true`, validates the specified configuration without creating or updating the TraceTailSamplingRules. If the specified configuration is valid, the endpoint returns a partial response without the TraceTailSamplingRules. If the specified configuration is invalid, the endpoint returns an error.",
          "type": "boolean"
        },
        "trace_tail_sampling_rules": {
          "allOf": [
            {
              "$ref": "#/definitions/configv1TraceTailSamplingRules"
            }
          ],
          "description": "The TraceTailSamplingRules to update."
        }
      },
      "type": "object"
    },
    "configv1UpdateTraceTailSamplingRulesResponse": {
      "properties": {
        "trace_tail_sampling_rules": {
          "$ref": "#/definitions/configv1TraceTailSamplingRules"
        }
      },
      "type": "object"
    },
    "genericError": {
      "additionalProperties": true,
      "type": "object"
    },
    "protobufAny": {
      "additionalProperties": {},
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "info": {
    "description": "\nThe Config API provides standard HTTP/JSON REST endpoints for creating, reading,\nupdating, deleting, and listing configurable Chronosphere resources.\n\nUse this link to download the raw Swagger specification:\n\u003ca href=\"/api/v1/config/swagger.json\"\u003e/api/v1/config/swagger.json\u003c/a\u003e\n",
    "title": "Config V1 API",
    "version": "v1"
  },
  "paths": {
    "/api/v1/config/azure-metrics-integrations": {
      "get": {
        "operationId": "ListAzureMetricsIntegrations",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any AzureMetricsIntegration with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any AzureMetricsIntegration with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListAzureMetricsIntegrationsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "post": {
        "operationId": "CreateAzureMetricsIntegration",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateAzureMetricsIntegrationRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1CreateAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot create the AzureMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the AzureMetricsIntegration because there is a conflict with an existing AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/azure-metrics-integrations/{slug}": {
      "delete": {
        "operationId": "DeleteAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot delete the AzureMetricsIntegration because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "get": {
        "operationId": "ReadAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadAzureMetricsIntegrationResponse"
            }
          },
          "404": {
            "description": "Cannot read the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      },
      "put": {
        "operationId": "UpdateAzureMetricsIntegration",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateAzureMetricsIntegrationBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateAzureMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot update the AzureMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the AzureMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the AzureMetricsIntegration because there is a conflict with an existing AzureMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "AzureMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/buckets": {
      "get": {
        "operationId": "ListBuckets",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Bucket with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Bucket with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListBucketsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "post": {
        "operationId": "CreateBucket",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1CreateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot create the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/buckets/{slug}": {
      "delete": {
        "operationId": "DeleteBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "description": "force_delete indicates deletion of the bucket and all resources that reference the bucket.\nThis includes monitors, dashboards, notification policies, recording rules, and alerts.",
            "in": "query",
            "name": "force_delete",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteBucketResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Bucket because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "get": {
        "operationId": "ReadBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadBucketResponse"
            }
          },
          "404": {
            "description": "Cannot read the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      },
      "put": {
        "operationId": "UpdateBucket",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateBucketBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Bucket.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateBucketResponse"
            }
          },
          "400": {
            "description": "Cannot update the Bucket because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Bucket because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Bucket because there is a conflict with an existing Bucket.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Bucket"
        ]
      }
    },
    "/api/v1/config/classic-dashboards": {
      "get": {
        "operationId": "ListClassicDashboards",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ClassicDashboard with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any ClassicDashboard with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any ClassicDashboard with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ClassicDashboard with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListClassicDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "post": {
        "operationId": "CreateClassicDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/classic-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "get": {
        "operationId": "ReadClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadClassicDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateClassicDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateClassicDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateClassicDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ClassicDashboard"
        ]
      }
    },
    "/api/v1/config/collections": {
      "get": {
        "operationId": "ListCollections",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Collection with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any Collection with a matching team_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Collection with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get collections that directly reference notification policies specified in\nthis array. To specify a notification policy, include its slug.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListCollectionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "post": {
        "operationId": "CreateCollection",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Collection.",
            "schema": {
              "$ref": "#/definitions/configv1CreateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot create the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/collections/{slug}": {
      "delete": {
        "operationId": "DeleteCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Collection because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "get": {
        "operationId": "ReadCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadCollectionResponse"
            }
          },
          "404": {
            "description": "Cannot read the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      },
      "put": {
        "operationId": "UpdateCollection",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateCollectionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Collection.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateCollectionResponse"
            }
          },
          "400": {
            "description": "Cannot update the Collection because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Collection because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Collection because there is a conflict with an existing Collection.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Collection"
        ]
      }
    },
    "/api/v1/config/consumption-budgets": {
      "get": {
        "operationId": "ListConsumptionBudgets",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ConsumptionBudget with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ConsumptionBudget with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by partition_slug_path, where any ConsumptionBudget with a matching partition_slug_path in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "partition_slug_paths",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by resource, where any ConsumptionBudget with a matching resource in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "enum": [
                "LOG_PERSISTED_BYTES",
                "LOG_PROCESSED_BYTES",
                "METRIC_PERSISTED_SERIES"
              ],
              "type": "string"
            },
            "name": "resources",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListConsumptionBudgetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "post": {
        "operationId": "CreateConsumptionBudget",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionBudgetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot create the ConsumptionBudget because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ConsumptionBudget because there is a conflict with an existing ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      }
    },
    "/api/v1/config/consumption-budgets/{slug}": {
      "delete": {
        "operationId": "DeleteConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ConsumptionBudget because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "get": {
        "operationId": "ReadConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadConsumptionBudgetResponse"
            }
          },
          "404": {
            "description": "Cannot read the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      },
      "put": {
        "operationId": "UpdateConsumptionBudget",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateConsumptionBudgetBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateConsumptionBudgetResponse"
            }
          },
          "400": {
            "description": "Cannot update the ConsumptionBudget because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ConsumptionBudget because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the ConsumptionBudget because there is a conflict with an existing ConsumptionBudget.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionBudget"
        ]
      }
    },
    "/api/v1/config/consumption-config": {
      "delete": {
        "operationId": "DeleteConsumptionConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ConsumptionConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ConsumptionConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "get": {
        "operationId": "ReadConsumptionConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadConsumptionConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the ConsumptionConfig because ConsumptionConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "post": {
        "operationId": "CreateConsumptionConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the ConsumptionConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ConsumptionConfig because there is a conflict with an existing ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      },
      "put": {
        "operationId": "UpdateConsumptionConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateConsumptionConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ConsumptionConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateConsumptionConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the ConsumptionConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ConsumptionConfig because ConsumptionConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ConsumptionConfig"
        ]
      }
    },
    "/api/v1/config/dashboards": {
      "get": {
        "operationId": "ListDashboards",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dashboard with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Dashboard with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dashboard with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional. Flag to populate the `dashboard_json` field of the returned\ndashboards. By default, `dashboard_json` is empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "post": {
        "operationId": "CreateDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "get": {
        "operationId": "ReadDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      },
      "put": {
        "operationId": "UpdateDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dashboard because there is a conflict with an existing Dashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dashboard"
        ]
      }
    },
    "/api/v1/config/datasets": {
      "get": {
        "operationId": "ListDatasets",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Dataset with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Dataset with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Custom filtering option: list filtered down to a specific telemetry type.",
            "enum": [
              "TRACES",
              "LOGS"
            ],
            "in": "query",
            "name": "type",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDatasetsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "post": {
        "operationId": "CreateDataset",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot create the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/datasets/{slug}": {
      "delete": {
        "operationId": "DeleteDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Dataset because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "get": {
        "operationId": "ReadDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDatasetResponse"
            }
          },
          "404": {
            "description": "Cannot read the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      },
      "put": {
        "operationId": "UpdateDataset",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDatasetBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Dataset.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDatasetResponse"
            }
          },
          "400": {
            "description": "Cannot update the Dataset because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Dataset because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Dataset because there is a conflict with an existing Dataset.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Dataset"
        ]
      }
    },
    "/api/v1/config/derived-labels": {
      "get": {
        "operationId": "ListDerivedLabels",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedLabel with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedLabel with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedLabelsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "post": {
        "operationId": "CreateDerivedLabel",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-labels/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedLabel because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "get": {
        "operationId": "ReadDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedLabelResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedLabel",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedLabelBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedLabelResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedLabel because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedLabel because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedLabel because there is a conflict with an existing DerivedLabel.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedLabel"
        ]
      }
    },
    "/api/v1/config/derived-metrics": {
      "get": {
        "operationId": "ListDerivedMetrics",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DerivedMetric with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DerivedMetric with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDerivedMetricsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "post": {
        "operationId": "CreateDerivedMetric",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot create the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/derived-metrics/{slug}": {
      "delete": {
        "operationId": "DeleteDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DerivedMetric because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "get": {
        "operationId": "ReadDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDerivedMetricResponse"
            }
          },
          "404": {
            "description": "Cannot read the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      },
      "put": {
        "operationId": "UpdateDerivedMetric",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDerivedMetricBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDerivedMetricResponse"
            }
          },
          "400": {
            "description": "Cannot update the DerivedMetric because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DerivedMetric because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DerivedMetric because there is a conflict with an existing DerivedMetric.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DerivedMetric"
        ]
      }
    },
    "/api/v1/config/drop-rules": {
      "get": {
        "operationId": "ListDropRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any DropRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any DropRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListDropRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "post": {
        "operationId": "CreateDropRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/drop-rules/{slug}": {
      "delete": {
        "operationId": "DeleteDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the DropRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "get": {
        "operationId": "ReadDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadDropRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      },
      "put": {
        "operationId": "UpdateDropRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateDropRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated DropRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateDropRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the DropRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the DropRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the DropRule because there is a conflict with an existing DropRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "DropRule"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations": {
      "get": {
        "operationId": "ListGcpMetricsIntegrations",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GcpMetricsIntegration with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GcpMetricsIntegration with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGcpMetricsIntegrationsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "post": {
        "operationId": "CreateGcpMetricsIntegration",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot create the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/gcp-metrics-integrations/{slug}": {
      "delete": {
        "operationId": "DeleteGcpMetricsIntegration",
        "parameters": [
          {
            "description": "The unique slug that identifies the GcpMetricsIntegration to delete.",
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GcpMetricsIntegration because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "get": {
        "operationId": "ReadGcpMetricsIntegration",
        "parameters": [
          {
            "description": "The unique slug that identifies the GcpMetricsIntegration to read.",
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGcpMetricsIntegrationResponse"
            }
          },
          "404": {
            "description": "Cannot read the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      },
      "put": {
        "operationId": "UpdateGcpMetricsIntegration",
        "parameters": [
          {
            "description": "The unique slug that identifies the GcpMetricsIntegration to update.",
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGcpMetricsIntegrationBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGcpMetricsIntegrationResponse"
            }
          },
          "400": {
            "description": "Cannot update the GcpMetricsIntegration because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GcpMetricsIntegration because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GcpMetricsIntegration because there is a conflict with an existing GcpMetricsIntegration.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GcpMetricsIntegration"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards": {
      "get": {
        "operationId": "ListGrafanaDashboards",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any GrafanaDashboard with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any GrafanaDashboard with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any GrafanaDashboard with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any GrafanaDashboard with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "description": "Optional flag to populate the dashboard_json of the returned dashboards.\nBy default, dashboard_json will be left empty.",
            "in": "query",
            "name": "include_dashboard_json",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListGrafanaDashboardsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "post": {
        "operationId": "CreateGrafanaDashboard",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1CreateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot create the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/grafana-dashboards/{slug}": {
      "delete": {
        "operationId": "DeleteGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot delete the GrafanaDashboard because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "get": {
        "operationId": "ReadGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadGrafanaDashboardResponse"
            }
          },
          "404": {
            "description": "Cannot read the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      },
      "put": {
        "operationId": "UpdateGrafanaDashboard",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateGrafanaDashboardBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateGrafanaDashboardResponse"
            }
          },
          "400": {
            "description": "Cannot update the GrafanaDashboard because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the GrafanaDashboard because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the GrafanaDashboard because there is a conflict with an existing GrafanaDashboard.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "GrafanaDashboard"
        ]
      }
    },
    "/api/v1/config/log-allocation-config": {
      "delete": {
        "operationId": "DeleteLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogAllocationConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogAllocationConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogAllocationConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogAllocationConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogAllocationConfig because there is a conflict with an existing LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogAllocationConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogAllocationConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogAllocationConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogAllocationConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogAllocationConfig because LogAllocationConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogAllocationConfig"
        ]
      }
    },
    "/api/v1/config/log-control-config": {
      "delete": {
        "operationId": "DeleteLogControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogControlConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogControlConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogControlConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogControlConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogControlConfig because LogControlConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogControlConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogControlConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogControlConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogControlConfig because there is a conflict with an existing LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogControlConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogControlConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogControlConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogControlConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogControlConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogControlConfig because LogControlConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogControlConfig"
        ]
      }
    },
    "/api/v1/config/log-ingest-config": {
      "delete": {
        "operationId": "DeleteLogIngestConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogIngestConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogIngestConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "get": {
        "operationId": "ReadLogIngestConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogIngestConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogIngestConfig because LogIngestConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "post": {
        "operationId": "CreateLogIngestConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogIngestConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogIngestConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogIngestConfig because there is a conflict with an existing LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      },
      "put": {
        "operationId": "UpdateLogIngestConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogIngestConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogIngestConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogIngestConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogIngestConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogIngestConfig because LogIngestConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogIngestConfig"
        ]
      }
    },
    "/api/v1/config/log-scale-actions": {
      "get": {
        "operationId": "ListLogScaleActions",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAction with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAction with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleActionsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAction",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-actions/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAction because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleActionResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAction",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleActionBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleActionResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAction because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAction because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAction because there is a conflict with an existing LogScaleAction.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAction"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts": {
      "get": {
        "operationId": "ListLogScaleAlerts",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any LogScaleAlert with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any LogScaleAlert with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListLogScaleAlertsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "post": {
        "operationId": "CreateLogScaleAlert",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1CreateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot create the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/log-scale-alerts/{slug}": {
      "delete": {
        "operationId": "DeleteLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot delete the LogScaleAlert because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "get": {
        "operationId": "ReadLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadLogScaleAlertResponse"
            }
          },
          "404": {
            "description": "Cannot read the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      },
      "put": {
        "operationId": "UpdateLogScaleAlert",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateLogScaleAlertBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateLogScaleAlertResponse"
            }
          },
          "400": {
            "description": "Cannot update the LogScaleAlert because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the LogScaleAlert because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the LogScaleAlert because there is a conflict with an existing LogScaleAlert.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "LogScaleAlert"
        ]
      }
    },
    "/api/v1/config/mapping-rules": {
      "get": {
        "operationId": "ListMappingRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MappingRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any MappingRule with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MappingRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMappingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "post": {
        "operationId": "CreateMappingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/mapping-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MappingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "get": {
        "operationId": "ReadMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMappingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMappingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMappingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MappingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMappingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MappingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MappingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MappingRule because there is a conflict with an existing MappingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MappingRule"
        ]
      }
    },
    "/api/v1/config/monitors": {
      "get": {
        "operationId": "ListMonitors",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Monitor with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any Monitor with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by collection_slug, where any Monitor with a matching collection_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Monitor with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter returned monitors by the teams that own the collections that they belong to.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMonitorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "post": {
        "operationId": "CreateMonitor",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot create the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/monitors/{slug}": {
      "delete": {
        "operationId": "DeleteMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Monitor because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "get": {
        "operationId": "ReadMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMonitorResponse"
            }
          },
          "404": {
            "description": "Cannot read the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      },
      "put": {
        "operationId": "UpdateMonitor",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMonitorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Monitor.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMonitorResponse"
            }
          },
          "400": {
            "description": "Cannot update the Monitor because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Monitor because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Monitor because there is a conflict with an existing Monitor.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Monitor"
        ]
      }
    },
    "/api/v1/config/muting-rules": {
      "get": {
        "operationId": "ListMutingRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any MutingRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any MutingRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Lists muting rules filtered by the states. If empty, all muting rules are\nincluded.",
            "in": "query",
            "items": {
              "enum": [
                "PENDING",
                "ACTIVE",
                "EXPIRED"
              ],
              "type": "string"
            },
            "name": "states",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListMutingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "post": {
        "operationId": "CreateMutingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/muting-rules/{slug}": {
      "delete": {
        "operationId": "DeleteMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the MutingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "get": {
        "operationId": "ReadMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadMutingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      },
      "put": {
        "operationId": "UpdateMutingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateMutingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated MutingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateMutingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the MutingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the MutingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the MutingRule because there is a conflict with an existing MutingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "MutingRule"
        ]
      }
    },
    "/api/v1/config/notification-policies": {
      "get": {
        "operationId": "ListNotificationPolicies",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any NotificationPolicy with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any NotificationPolicy with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any NotificationPolicy with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by team_slug, where any NotificationPolicy with a matching team_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotificationPoliciesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "post": {
        "operationId": "CreateNotificationPolicy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot create the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notification-policies/{slug}": {
      "delete": {
        "operationId": "DeleteNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the NotificationPolicy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "get": {
        "operationId": "ReadNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotificationPolicyResponse"
            }
          },
          "404": {
            "description": "Cannot read the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      },
      "put": {
        "operationId": "UpdateNotificationPolicy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotificationPolicyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotificationPolicyResponse"
            }
          },
          "400": {
            "description": "Cannot update the NotificationPolicy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the NotificationPolicy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the NotificationPolicy because there is a conflict with an existing NotificationPolicy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "NotificationPolicy"
        ]
      }
    },
    "/api/v1/config/notifiers": {
      "get": {
        "operationId": "ListNotifiers",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Notifier with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Notifier with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListNotifiersResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "post": {
        "operationId": "CreateNotifier",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1CreateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot create the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/notifiers/{slug}": {
      "delete": {
        "operationId": "DeleteNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Notifier because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "get": {
        "operationId": "ReadNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadNotifierResponse"
            }
          },
          "404": {
            "description": "Cannot read the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      },
      "put": {
        "operationId": "UpdateNotifier",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateNotifierBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Notifier.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateNotifierResponse"
            }
          },
          "400": {
            "description": "Cannot update the Notifier because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Notifier because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Notifier because there is a conflict with an existing Notifier.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Notifier"
        ]
      }
    },
    "/api/v1/config/otel-metrics-ingestion": {
      "delete": {
        "operationId": "DeleteOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot delete the OtelMetricsIngestion because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the OtelMetricsIngestion because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "get": {
        "operationId": "ReadOtelMetricsIngestion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadOtelMetricsIngestionResponse"
            }
          },
          "404": {
            "description": "Cannot read the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "post": {
        "operationId": "CreateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1CreateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot create the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the OtelMetricsIngestion because there is a conflict with an existing OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      },
      "put": {
        "operationId": "UpdateOtelMetricsIngestion",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated OtelMetricsIngestion.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateOtelMetricsIngestionResponse"
            }
          },
          "400": {
            "description": "Cannot update the OtelMetricsIngestion because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the OtelMetricsIngestion because OtelMetricsIngestion has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "OtelMetricsIngestion"
        ]
      }
    },
    "/api/v1/config/recording-rules": {
      "get": {
        "operationId": "ListRecordingRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RecordingRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RecordingRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The execution_groups filter cannot be used when a bucket_slug filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "The bucket_slugs filter cannot be used when an execution_group filter is provided.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "execution_groups",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRecordingRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "post": {
        "operationId": "CreateRecordingRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/recording-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RecordingRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "get": {
        "operationId": "ReadRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRecordingRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      },
      "put": {
        "operationId": "UpdateRecordingRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRecordingRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RecordingRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRecordingRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RecordingRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RecordingRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RecordingRule because there is a conflict with an existing RecordingRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RecordingRule"
        ]
      }
    },
    "/api/v1/config/resource-pools": {
      "delete": {
        "operationId": "DeleteResourcePools",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ResourcePools because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ResourcePools because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "get": {
        "operationId": "ReadResourcePools",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadResourcePoolsResponse"
            }
          },
          "404": {
            "description": "Cannot read the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "post": {
        "description": "ResourcePools CRUD (subset for singleton objects)",
        "operationId": "CreateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1CreateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot create the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ResourcePools because there is a conflict with an existing ResourcePools.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      },
      "put": {
        "operationId": "UpdateResourcePools",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated ResourcePools.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateResourcePoolsResponse"
            }
          },
          "400": {
            "description": "Cannot update the ResourcePools because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the ResourcePools because ResourcePools has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ResourcePools"
        ]
      }
    },
    "/api/v1/config/rollup-rules": {
      "get": {
        "operationId": "ListRollupRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any RollupRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any RollupRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by bucket_slug, where any RollupRule with a matching bucket_slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "bucket_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListRollupRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "post": {
        "operationId": "CreateRollupRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/rollup-rules/{slug}": {
      "delete": {
        "operationId": "DeleteRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the RollupRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "get": {
        "operationId": "ReadRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadRollupRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      },
      "put": {
        "operationId": "UpdateRollupRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateRollupRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated RollupRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateRollupRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the RollupRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the RollupRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the RollupRule because there is a conflict with an existing RollupRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "RollupRule"
        ]
      }
    },
    "/api/v1/config/service-accounts": {
      "get": {
        "operationId": "ListServiceAccounts",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any ServiceAccount with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any ServiceAccount with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServiceAccountsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "post": {
        "operationId": "CreateServiceAccount",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot create the ServiceAccount because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the ServiceAccount because there is a conflict with an existing ServiceAccount.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/service-accounts/{slug}": {
      "delete": {
        "operationId": "DeleteServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteServiceAccountResponse"
            }
          },
          "400": {
            "description": "Cannot delete the ServiceAccount because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      },
      "get": {
        "operationId": "ReadServiceAccount",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceAccountResponse"
            }
          },
          "404": {
            "description": "Cannot read the ServiceAccount because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAccount"
        ]
      }
    },
    "/api/v1/config/service-attributes": {
      "get": {
        "operationId": "ListServiceAttributes",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServiceAttributesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "ServiceAttribute"
        ]
      }
    },
    "/api/v1/config/services": {
      "get": {
        "operationId": "ListServices",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Service with a matching slug in the given\nlist that matches all other filters is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by `team_slug`, where any Service with a matching `team_slug` in\nthe given list that matches all other filters is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "team_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by `name`, where any Service with a matching `name` in the given\nlist that matches all other filters is returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by `notification_policy_slug`, where any Service with a matching\n`notification_policy_slug` in the given list that matches all other filters is\nreturned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "notification_policy_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListServicesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/services/{service_slug}/attributes": {
      "delete": {
        "operationId": "DeleteServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      },
      "get": {
        "operationId": "ReadServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      },
      "post": {
        "operationId": "CreateServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1CreateServiceAttributeBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1CreateServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      },
      "put": {
        "operationId": "UpdateServiceAttribute",
        "parameters": [
          {
            "in": "path",
            "name": "service_slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateServiceAttributeBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateServiceAttributeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          }
        },
        "tags": [
          "ConfigV1"
        ]
      }
    },
    "/api/v1/config/services/{slug}": {
      "get": {
        "operationId": "ReadService",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadServiceResponse"
            }
          },
          "404": {
            "description": "Cannot read the Service because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/api/v1/config/slos": {
      "get": {
        "operationId": "ListSLOs",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any SLO with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any SLO with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "collection_slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_slugs",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListSLOsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "post": {
        "operationId": "CreateSLO",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateSLORequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created SLO.",
            "schema": {
              "$ref": "#/definitions/configv1CreateSLOResponse"
            }
          },
          "400": {
            "description": "Cannot create the SLO because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the SLO because there is a conflict with an existing SLO.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      }
    },
    "/api/v1/config/slos/{slug}": {
      "delete": {
        "operationId": "DeleteSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteSLOResponse"
            }
          },
          "400": {
            "description": "Cannot delete the SLO because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "get": {
        "operationId": "ReadSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadSLOResponse"
            }
          },
          "404": {
            "description": "Cannot read the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      },
      "put": {
        "operationId": "UpdateSLO",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateSLOBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated SLO.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateSLOResponse"
            }
          },
          "400": {
            "description": "Cannot update the SLO because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the SLO because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the SLO because there is a conflict with an existing SLO.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "SLO"
        ]
      }
    },
    "/api/v1/config/teams": {
      "get": {
        "operationId": "ListTeams",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any Team with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any Team with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTeamsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "post": {
        "operationId": "CreateTeam",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created Team.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot create the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/teams/{slug}": {
      "delete": {
        "operationId": "DeleteTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTeamResponse"
            }
          },
          "400": {
            "description": "Cannot delete the Team because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "get": {
        "operationId": "ReadTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTeamResponse"
            }
          },
          "404": {
            "description": "Cannot read the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      },
      "put": {
        "operationId": "UpdateTeam",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTeamBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated Team.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTeamResponse"
            }
          },
          "400": {
            "description": "Cannot update the Team because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the Team because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the Team because there is a conflict with an existing Team.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "Team"
        ]
      }
    },
    "/api/v1/config/trace-behavior-config": {
      "delete": {
        "operationId": "DeleteTraceBehaviorConfig",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehaviorConfig because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehaviorConfig because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehaviorConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorConfigResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehaviorConfig because there is a conflict with an existing TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehaviorConfig",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehaviorConfig.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorConfigResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehaviorConfig because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehaviorConfig because TraceBehaviorConfig has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehaviorConfig"
        ]
      }
    },
    "/api/v1/config/trace-behaviors": {
      "get": {
        "operationId": "ListTraceBehaviors",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceBehavior with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceBehavior with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceBehaviorsResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "post": {
        "operationId": "CreateTraceBehavior",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-behaviors/{slug}": {
      "delete": {
        "operationId": "DeleteTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceBehavior because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "get": {
        "operationId": "ReadTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceBehaviorResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      },
      "put": {
        "operationId": "UpdateTraceBehavior",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceBehaviorBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceBehaviorResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceBehavior because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceBehavior because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceBehavior because there is a conflict with an existing TraceBehavior.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceBehavior"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies": {
      "get": {
        "operationId": "ListTraceJaegerRemoteSamplingStrategies",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceJaegerRemoteSamplingStrategy with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceJaegerRemoteSamplingStrategy with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by service_name, where any TraceJaegerRemoteSamplingStrategy with a matching service_name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "service_names",
            "type": "array"
          },
          {
            "in": "query",
            "name": "name_or_service_contains",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceJaegerRemoteSamplingStrategiesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "post": {
        "operationId": "CreateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-jaeger-remote-sampling-strategies/{slug}": {
      "delete": {
        "operationId": "DeleteTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "get": {
        "operationId": "ReadTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      },
      "put": {
        "operationId": "UpdateTraceJaegerRemoteSamplingStrategy",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceJaegerRemoteSamplingStrategyBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceJaegerRemoteSamplingStrategyResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceJaegerRemoteSamplingStrategy because there is a conflict with an existing TraceJaegerRemoteSamplingStrategy.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceJaegerRemoteSamplingStrategy"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules": {
      "get": {
        "operationId": "ListTraceMetricsRules",
        "parameters": [
          {
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64",
            "in": "query",
            "name": "page.max_size",
            "type": "integer"
          },
          {
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "in": "query",
            "name": "page.token",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by slug, where any TraceMetricsRule with a matching slug in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "slugs",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filters results by name, where any TraceMetricsRule with a matching name in the given list (and matches all other filters) will be returned.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "names",
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Get trace metric rules by name.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "metric_names",
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ListTraceMetricsRulesResponse"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "post": {
        "description": "***\nTrace Metrics Rules\n***",
        "operationId": "CreateTraceMetricsRule",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-metrics-rules/{slug}": {
      "delete": {
        "operationId": "DeleteTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceMetricsRule because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "get": {
        "operationId": "ReadTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceMetricsRuleResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      },
      "put": {
        "operationId": "UpdateTraceMetricsRule",
        "parameters": [
          {
            "in": "path",
            "name": "slug",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ConfigV1UpdateTraceMetricsRuleBody"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceMetricsRuleResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceMetricsRule because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceMetricsRule because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot update the TraceMetricsRule because there is a conflict with an existing TraceMetricsRule.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceMetricsRule"
        ]
      }
    },
    "/api/v1/config/trace-tail-sampling-rules": {
      "delete": {
        "operationId": "DeleteTraceTailSamplingRules",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1DeleteTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot delete the TraceTailSamplingRules because it is in use.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot delete the TraceTailSamplingRules because the slug does not exist.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "get": {
        "operationId": "ReadTraceTailSamplingRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/configv1ReadTraceTailSamplingRulesResponse"
            }
          },
          "404": {
            "description": "Cannot read the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "post": {
        "description": "TraceTailSamplingRules CRUD (subset for singleton objects)",
        "operationId": "CreateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the created TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1CreateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot create the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "409": {
            "description": "Cannot create the TraceTailSamplingRules because there is a conflict with an existing TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      },
      "put": {
        "operationId": "UpdateTraceTailSamplingRules",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response containing the updated TraceTailSamplingRules.",
            "schema": {
              "$ref": "#/definitions/configv1UpdateTraceTailSamplingRulesResponse"
            }
          },
          "400": {
            "description": "Cannot update the TraceTailSamplingRules because the request is invalid.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "404": {
            "description": "Cannot update the TraceTailSamplingRules because TraceTailSamplingRules has not been created.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "500": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/apiError"
            }
          },
          "default": {
            "description": "An undefined error response.",
            "schema": {
              "$ref": "#/definitions/genericError"
            }
          }
        },
        "tags": [
          "TraceTailSamplingRules"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "security": [
    {
      "ApiKeyAuth": []
    }
  ],
  "securityDefinitions": {
    "ApiKeyAuth": {
      "description": "Chronosphere API token",
      "in": "header",
      "name": "API-Token",
      "type": "apiKey"
    }
  },
  "swagger": "2.0",
  "tags": [
    {
      "name": "ConfigV1"
    }
  ]
}