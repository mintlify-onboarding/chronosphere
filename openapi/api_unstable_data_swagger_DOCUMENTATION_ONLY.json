{
  "openapi": "3.0.1",
  "info": {
    "title": "Data Unstable API",
    "description": "\n<b>WARNING: This API is unstable and is meant for experimentation only. Do not\nuse this API in production. The endpoints and schemas referenced in this\ndocumentation will be changed or removed without notice and without any\nbackwards compatibility guarantee. Note that even though this API is unstable,\nit is still connected to production data, so use with caution.</b>",
    "version": "v1"
  },
  "servers": [
    {
      "url": "/"
    }
  ],
  "security": [
    {
      "ApiKeyAuth": []
    }
  ],
  "tags": [
    {
      "name": "DataUnstable"
    }
  ],
  "paths": {
    "/api/unstable/data/events": {
      "get": {
        "tags": [
          "DataUnstable"
        ],
        "operationId": "ListEvents",
        "parameters": [
          {
            "name": "happened_after",
            "in": "query",
            "description": "Only events which happened_at after this time will be returned. If set, happened_before must also be set.\nIf no time range is set, defaults to 1 hour ago.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "happened_before",
            "in": "query",
            "description": "Only events which happened_at before this will be returned. If set, happened_after must also be set.\nIf no time range is set, defaults to now.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "query",
            "in": "query",
            "description": "A query string specifying the query.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page.max_size",
            "in": "query",
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "page.token",
            "in": "query",
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dataunstableListEventsResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/googlerpcStatus"
                }
              }
            }
          }
        }
      }
    },
    "/api/unstable/data/logs:get-range-query": {
      "get": {
        "tags": [
          "DataUnstable"
        ],
        "description": "GetRangeQuery returns a range query.",
        "operationId": "GetRangeQuery",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "description": "Specifies the query to run to filter logs. Query defined using logql.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestamp_filter.happened_after",
            "in": "query",
            "description": "Only log messages with a timestamp after this time will be returned.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "timestamp_filter.happened_before",
            "in": "query",
            "description": "Only log messages with a timestamp before this time will be returned.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "page.token",
            "in": "query",
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dataunstableGetRangeQueryResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/googlerpcStatus"
                }
              }
            }
          }
        }
      }
    },
    "/api/unstable/data/traces": {
      "post": {
        "tags": [
          "DataUnstable"
        ],
        "description": "Tracing",
        "operationId": "ListTraces",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/datav1ListTracesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/datav1ListTracesResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/googlerpcStatus"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    }
  },
  "components": {
    "schemas": {
      "AnalyzeAlertsRequestAlertFilter": {
        "type": "object",
        "properties": {
          "is_muted": {
            "type": "boolean",
            "description": "Filter alerts by mute status"
          },
          "monitor_labels": {
            "type": "object",
            "description": "Optional: limit considered alerts to those having the given monitor labels.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestLabelsMatcher"
              }
            ]
          },
          "monitor_slug": {
            "type": "object",
            "description": "Optional: limit considered alerts to those from a specific monitor.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestStringMatcher"
              }
            ]
          },
          "notification_policy_slug": {
            "type": "object",
            "description": "Optional: limit considered alerts to those from a specific notification policy.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestStringMatcher"
              }
            ]
          },
          "signals": {
            "type": "object",
            "description": "Optional: limit considered alerts to those having the given signals.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestLabelsMatcher"
              }
            ]
          }
        },
        "description": "AlertFilter contains semantic filter options for alert analysis queries (list, aggregate, etc).\nIMPORTANT: ALL fields in this message now use AND semantics when combined.\nTo achieve OR semantics between criteria, use multiple AlertFilter instances\nwith alert_filters_combine_mode = OR in the request."
      },
      "AnalyzeAlertsRequestAlertFiltersCombineMode": {
        "title": "AlertFiltersCombineMode specifies how multiple AlertFilters are combined",
        "type": "string",
        "description": "- ALERT_FILTERS_OR: At least one filter must match",
        "enum": [
          "ALERT_FILTERS_OR"
        ]
      },
      "AnalyzeAlertsRequestLabelMatcher": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The label key to match against"
          },
          "value": {
            "type": "object",
            "description": "String matcher to apply to the label value",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestStringMatcher"
              }
            ]
          }
        },
        "description": "LabelMatcher provides label matching with advanced string operations.\nCombines a specific label key with flexible value matching."
      },
      "AnalyzeAlertsRequestLabelsMatcher": {
        "type": "object",
        "properties": {
          "labels": {
            "type": "array",
            "description": "List of label matchers to apply",
            "items": {
              "$ref": "#/components/schemas/AnalyzeAlertsRequestLabelMatcher"
            }
          },
          "min_matches": {
            "type": "integer",
            "description": "Minimum number of label matches required for this matcher to be satisfied.\nIf not set, defaults to requiring at least one match when labels are specified.",
            "format": "int32"
          }
        },
        "description": "LabelsMatcher provides label matching with general per-label matching operations."
      },
      "AnalyzeAlertsRequestStringMatcher": {
        "type": "object",
        "properties": {
          "multi_value": {
            "type": "array",
            "description": "Multiple values for operations that work with multiple values (ANY_OF, NONE_OF)",
            "items": {
              "type": "string"
            }
          },
          "operation": {
            "type": "object",
            "description": "The type of matching operation to perform",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestStringMatcherOperation"
              }
            ]
          },
          "single_value": {
            "type": "string",
            "description": "Single value for operations that work with one value (EQUAL, REGEX_EQUAL, CONTAINS, etc.)"
          }
        },
        "description": "StringMatcher provides advanced string matching operations.\nUsed throughout the API for flexible filtering of string fields."
      },
      "AnalyzeAlertsRequestStringMatcherOperation": {
        "type": "string",
        "description": "StringMatcherOperation defines the type of string matching operation.\n\n - EQUAL: Exact string equality\n - REGEX_EQUAL: Regular expression matching\n - CONTAINS: String contains (substring match)\n - NOT_EQUAL: Not equal to string\n - NOT_REGEX_EQUAL: Does not match regular expression\n - NOT_CONTAINS: Does not contain (no substring match)\n - ANY_OF: Matches any of the provided values\n - NONE_OF: Matches none of the provided values",
        "enum": [
          "EQUAL",
          "REGEX_EQUAL",
          "CONTAINS",
          "NOT_EQUAL",
          "NOT_REGEX_EQUAL",
          "NOT_CONTAINS",
          "ANY_OF",
          "NONE_OF"
        ]
      },
      "AnalyzeAlertsRequestTimeFilter": {
        "type": "object",
        "properties": {
          "end_time": {
            "type": "string",
            "description": "End time for the filter (exclusive)",
            "format": "date-time"
          },
          "max_duration_seconds": {
            "type": "integer",
            "description": "Maximum alert duration in seconds. Filters alerts where duration <= this value",
            "format": "int32"
          },
          "min_duration_seconds": {
            "type": "integer",
            "description": "Minimum alert duration in seconds. Filters alerts where duration >= this value",
            "format": "int32"
          },
          "start_time": {
            "type": "string",
            "description": "Start time for the filter (inclusive)",
            "format": "date-time"
          }
        },
        "description": "TimeFilter provides a time range for filtering alert events."
      },
      "AnalyzeAlertsResponseAlert": {
        "type": "object",
        "properties": {
          "alert_id": {
            "type": "string",
            "description": "Unique identifier for this alert instance"
          },
          "end_time": {
            "type": "string",
            "description": "When this alert resolved (if it has resolved)",
            "format": "date-time"
          },
          "is_muted": {
            "type": "boolean",
            "description": "Whether this alert is currently muted"
          },
          "monitor_label_match_count": {
            "type": "integer",
            "description": "Number of monitor labels that matched the filter criteria (if monitor_labels filter was provided)",
            "format": "int32"
          },
          "monitor_labels": {
            "type": "array",
            "description": "Labels attached to the monitor that generated this alert",
            "items": {
              "$ref": "#/components/schemas/dataunstableAnalyzeAlertsResponseLabel"
            }
          },
          "monitor_labels_hash": {
            "type": "string",
            "description": "Hash of monitor labels for grouping alerts from monitors with identical label sets.",
            "format": "int64"
          },
          "monitor_name": {
            "type": "string",
            "description": "Human-readable name of the monitor"
          },
          "monitor_slug": {
            "type": "string",
            "description": "Slug of the monitor that generated this alert"
          },
          "mute_history": {
            "type": "array",
            "description": "Historical record of mute/unmute actions",
            "items": {
              "$ref": "#/components/schemas/AnalyzeAlertsResponseMuteActionHistoryEntry"
            }
          },
          "notification_policy_name": {
            "type": "string",
            "description": "Human-readable name of the notification policy"
          },
          "notification_policy_slug": {
            "type": "string",
            "description": "Slug of the notification policy handling this alert"
          },
          "notifier_history": {
            "type": "array",
            "description": "Historical record of notification attempts",
            "items": {
              "$ref": "#/components/schemas/AnalyzeAlertsResponseNotifierHistoryEntry"
            }
          },
          "ownership_context": {
            "type": "object",
            "description": "Ownership context for the monitor",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsResponseOwnershipContext"
              }
            ]
          },
          "severity_history": {
            "type": "array",
            "description": "Historical record of severity changes throughout the alert lifecycle",
            "items": {
              "$ref": "#/components/schemas/AnalyzeAlertsResponseSeverityChangeHistoryEntry"
            }
          },
          "signal": {
            "type": "array",
            "description": "If configured, key-value pairs (labels, from telemetry) that semantically characterize the alert further.",
            "items": {
              "$ref": "#/components/schemas/dataunstableAnalyzeAlertsResponseLabel"
            }
          },
          "signal_match_count": {
            "type": "integer",
            "description": "Number of signals that matched the filter criteria (if signals filter was provided)",
            "format": "int32"
          },
          "signals_hash": {
            "type": "string",
            "description": "Hash of signals for grouping alerts with identical signal combinations.",
            "format": "int64"
          },
          "slo_metadata": {
            "type": "object",
            "description": "SLO metadata if this alert is from an SLO-generated monitor",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsResponseSloMetadata"
              }
            ]
          },
          "start_time": {
            "type": "string",
            "description": "When this alert first triggered",
            "format": "date-time"
          }
        },
        "description": "Alert represents a logical alert with its lifecycle and history.\nThis type is specific to analytical access patterns in this package.\nContains complete alert metadata, timing, and historical events."
      },
      "AnalyzeAlertsResponseMuteActionHistoryEntry": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "The action taken: \"MUTED\" or \"UNMUTED\""
          },
          "timestamp": {
            "type": "string",
            "description": "When this mute action occurred",
            "format": "date-time"
          }
        },
        "description": "MuteActionHistoryEntry represents a mute/unmute action during the alert lifecycle.\nTracks when an alert was manually muted or unmuted."
      },
      "AnalyzeAlertsResponseNotifierHistoryEntry": {
        "type": "object",
        "properties": {
          "notifier_name": {
            "type": "string",
            "description": "Human-readable name of the notifier"
          },
          "notifier_slug": {
            "type": "string",
            "description": "Slug identifier of the notifier"
          },
          "send_success": {
            "type": "boolean",
            "description": "Whether the notification was successfully sent"
          },
          "severity": {
            "type": "string",
            "description": "Severity level when this notification was sent"
          },
          "timestamp": {
            "type": "string",
            "description": "When the notification attempt occurred",
            "format": "date-time"
          }
        },
        "description": "NotifierHistoryEntry represents a notifier send attempt during the alert lifecycle.\nTracks all notification attempts made for this alert."
      },
      "AnalyzeAlertsResponseOwnershipContext": {
        "type": "object",
        "properties": {
          "collection_id": {
            "type": "string",
            "description": "Collection that owns the monitor"
          },
          "collection_slug": {
            "type": "string"
          },
          "entity_group_id": {
            "type": "string",
            "description": "Entity group that owns the monitor"
          },
          "entity_group_slug": {
            "type": "string"
          }
        },
        "description": "OwnershipContext contains ownership information for the monitor.\nProvides hierarchical ownership context from entity groups and collections."
      },
      "AnalyzeAlertsResponseSeverityChangeHistoryEntry": {
        "type": "object",
        "properties": {
          "severity": {
            "type": "string",
            "description": "The new severity level (e.g., \"critical\", \"warning\")"
          },
          "timestamp": {
            "type": "string",
            "description": "When this severity change occurred",
            "format": "date-time"
          }
        },
        "description": "SeverityChangeHistoryEntry represents a severity change during the alert lifecycle.\nTracks when an alert's severity level changed over time."
      },
      "AnalyzeAlertsResponseSloMetadata": {
        "type": "object",
        "properties": {
          "category": {
            "type": "string",
            "description": "SLO category (e.g., \"availability\", \"latency\", \"error_rate\")"
          },
          "name": {
            "type": "string",
            "description": "SLO name"
          },
          "slug": {
            "type": "string",
            "description": "SLO slug identifier"
          }
        },
        "description": "SloMetadata contains metadata about an SLO-generated monitor.\nOnly present when the alert originates from an SLO monitor."
      },
      "EventBucketGroup": {
        "type": "object",
        "properties": {
          "count": {
            "type": "string",
            "description": "The count of events in this group within the bucket.",
            "format": "int64"
          },
          "name": {
            "type": "string",
            "description": "The name of this group within the bucket. Set to the value of the group_by field.\nUnset if group_by is unset."
          }
        },
        "description": "A single group of events within a bucket."
      },
      "ExecutionSummaryDashboard": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "slug": {
            "type": "string"
          }
        }
      },
      "GetLogClusterExecutionsRequestExecutionType": {
        "type": "string",
        "enum": [
          "LOG_EXPLORER",
          "DASHBOARD"
        ]
      },
      "GetLogClusterExecutionsResponseExecutionSummary": {
        "type": "object",
        "properties": {
          "count": {
            "type": "string",
            "format": "uint64"
          },
          "dashboard": {
            "$ref": "#/components/schemas/ExecutionSummaryDashboard"
          },
          "executions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GetLogClusterExecutionsResponseExecutionSummaryExecutions"
            }
          },
          "query": {
            "type": "string",
            "description": "either `query` or `dashboard` will be set, depending on the first level of grouping"
          }
        }
      },
      "GetLogClusterExecutionsResponseExecutionSummaryExecutions": {
        "type": "object",
        "properties": {
          "count": {
            "type": "string",
            "format": "uint64"
          },
          "dashboard": {
            "$ref": "#/components/schemas/ExecutionSummaryDashboard"
          },
          "user": {
            "type": "string",
            "description": "`dashboard` or `user` will not be set if we're not grouping by it"
          }
        }
      },
      "GetLogClusterUsageResponseRecommendation": {
        "type": "object",
        "properties": {
          "body_text": {
            "type": "string"
          },
          "header_text": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/RecommendationRecommendationType"
          }
        }
      },
      "GetLogClusterUsageResponseReferences": {
        "title": "not used initially",
        "type": "object",
        "properties": {
          "dashboards": {
            "type": "string",
            "format": "uint64"
          },
          "monitors": {
            "type": "string",
            "format": "uint64"
          },
          "saved_searches": {
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "GetLogClusterUsageResponseUsageBucket": {
        "type": "object",
        "properties": {
          "after": {
            "type": "string",
            "format": "date-time"
          },
          "before": {
            "type": "string",
            "format": "date-time"
          },
          "value": {
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "GetLoggingUsageRequestResponseOrderType": {
        "type": "string",
        "enum": [
          "UTILITY_ASC",
          "UTILITY_DESC",
          "VOLUME_ASC",
          "VOLUME_DESC",
          "VOLUME_24H_ASC",
          "VOLUME_24H_DESC"
        ]
      },
      "GetLoggingUsageResponseMetadata": {
        "type": "object",
        "properties": {
          "last_updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "total_bytes": {
            "type": "string",
            "format": "uint64"
          },
          "total_logs": {
            "type": "string",
            "format": "uint64"
          },
          "total_patterns": {
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "GetRangeQueryResponseRangeQueryMetadata": {
        "type": "object",
        "properties": {
          "limit_enforced": {
            "type": "boolean",
            "description": "This field indicates whether the result is truncated by the limit requested."
          },
          "page": {
            "type": "object",
            "description": "If set, there are more results to return.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableRangeQueryPageResult"
              }
            ]
          }
        }
      },
      "ListEventFieldValuesRequestScope": {
        "type": "object",
        "properties": {
          "categories": {
            "type": "array",
            "description": "The list of categories to scope event field values by.",
            "items": {
              "type": "string"
            }
          },
          "sources": {
            "type": "array",
            "description": "The list of sources to scope event field values by.",
            "items": {
              "type": "string"
            }
          },
          "types": {
            "type": "array",
            "description": "The list of types to scope event field values by.",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "The scope to apply to the query."
      },
      "ListTracesRequestQueryType": {
        "type": "string",
        "enum": [
          "TRACE_IDS",
          "SERVICE_OPERATION"
        ]
      },
      "ListTracesRequestTagFilter": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The key (or name) of the span tag that is inspected by this filter."
          },
          "numeric_value": {
            "type": "object",
            "description": "Matcher used to evaluate the span tag value as a numeric value (if the\ntag with the given key is found and the value type is numerical).",
            "allOf": [
              {
                "$ref": "#/components/schemas/TagFilterNumericFilter"
              }
            ]
          },
          "value": {
            "type": "object",
            "description": "Matcher used to evaluate the span tag value (if the tag with the given\nkey is found and the value type is a string).",
            "allOf": [
              {
                "$ref": "#/components/schemas/TagFilterStringFilter"
              }
            ]
          }
        }
      },
      "LogQueryTimeSeriesDataLogQueryTimeSeries": {
        "type": "object",
        "properties": {
          "aggregation_name": {
            "type": "string",
            "description": "aggregation_name is by default the name of the aggregation used to calculate\nthe values.\nIn the future we may support aliasing in query grammar."
          },
          "buckets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogQueryTimeSeriesLogQueryTimeSeriesBucket"
            }
          },
          "group_by_dimension_values": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "LogQueryTimeSeriesLogQueryTimeSeriesBucket": {
        "type": "object",
        "properties": {
          "end_time": {
            "type": "string",
            "description": "The end time of the time range this bucket covers.",
            "format": "date-time"
          },
          "float_value": {
            "type": "number",
            "format": "double"
          },
          "start_time": {
            "type": "string",
            "description": "The start time of the time range this bucket covers.",
            "format": "date-time"
          }
        }
      },
      "NumericFilterComparisonType": {
        "type": "string",
        "enum": [
          "EQUAL",
          "NOT_EQUAL",
          "GREATER_THAN",
          "GREATER_THAN_OR_EQUAL",
          "LESS_THAN",
          "LESS_THAN_OR_EQUAL"
        ]
      },
      "RecommendationRecommendationType": {
        "type": "string",
        "enum": [
          "DROP_LOG",
          "ADD_METRIC",
          "ADD_METRIC_AND_DROP"
        ]
      },
      "SpanLink": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "array",
            "description": "attributes is a collection of attribute key/value pairs on the link.\nAttribute keys MUST be unique (it is not allowed to have more than one\nattribute with the same key).",
            "items": {
              "$ref": "#/components/schemas/v1KeyValue"
            }
          },
          "dropped_attributes_count": {
            "type": "integer",
            "description": "dropped_attributes_count is the number of dropped attributes. If the value is 0,\nthen no attributes were dropped.",
            "format": "int64"
          },
          "flags": {
            "type": "integer",
            "description": "Flags, a bit field.\n\nBits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace\nContext specification. To read the 8-bit W3C trace flag, use\n`flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.\n\nSee https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.\n\nBits 8 and 9 represent the 3 states of whether the link is remote.\nThe states are (unknown, is not remote, is remote).\nTo read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.\nTo read whether the link is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.\n\nReaders MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.\nWhen creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.\n\n[Optional].",
            "format": "int64"
          },
          "span_id": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "A unique identifier for the linked span. The ID is an 8-byte array.",
            "format": "byte"
          },
          "trace_id": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "A unique identifier of a trace that this linked span is part of. The ID is a\n16-byte array.",
            "format": "byte"
          },
          "trace_state": {
            "type": "string",
            "description": "The trace_state associated with the link."
          }
        },
        "description": "A pointer from the current span to another span in the same trace or in a\ndifferent trace. For example, this can be used in batching operations,\nwhere a single batch handler processes multiple requests from different\ntraces or when the handler receives a request from a different project."
      },
      "SpanSpanKind": {
        "type": "string",
        "description": "SpanKind is the type of span. Can be used to specify additional relationships between spans\nin addition to a parent/child relationship.\n\n - SPAN_KIND_INTERNAL: Indicates that the span represents an internal operation within an application,\nas opposed to an operation happening at the boundaries. Default value.\n - SPAN_KIND_SERVER: Indicates that the span covers server-side handling of an RPC or other\nremote network request.\n - SPAN_KIND_CLIENT: Indicates that the span describes a request to some remote service.\n - SPAN_KIND_PRODUCER: Indicates that the span describes a producer sending a message to a broker.\nUnlike CLIENT and SERVER, there is often no direct critical path latency relationship\nbetween producer and consumer spans. A PRODUCER span ends when the message was accepted\nby the broker while the logical processing of the message might span a much longer time.\n - SPAN_KIND_CONSUMER: Indicates that the span describes consumer receiving a message from a broker.\nLike the PRODUCER kind, there is often no direct critical path latency relationship\nbetween producer and consumer spans.",
        "enum": [
          "SPAN_KIND_INTERNAL",
          "SPAN_KIND_SERVER",
          "SPAN_KIND_CLIENT",
          "SPAN_KIND_PRODUCER",
          "SPAN_KIND_CONSUMER"
        ]
      },
      "StatusStatusCode": {
        "title": "For the semantics of status codes see\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status",
        "type": "string",
        "description": "- STATUS_CODE_OK: The Span has been validated by an Application developer or Operator to \nhave completed successfully.\n - STATUS_CODE_ERROR: The Span contains an error.",
        "enum": [
          "STATUS_CODE_OK",
          "STATUS_CODE_ERROR"
        ]
      },
      "StringFilterStringFilterMatchType": {
        "type": "string",
        "enum": [
          "EXACT",
          "REGEX",
          "EXACT_NEGATION",
          "REGEX_NEGATION",
          "IN",
          "NOT_IN"
        ]
      },
      "TagFilterNumericFilter": {
        "type": "object",
        "properties": {
          "comparison": {
            "type": "object",
            "description": "The comparison operation to be applied to an input against the given filter value.",
            "allOf": [
              {
                "$ref": "#/components/schemas/NumericFilterComparisonType"
              }
            ]
          },
          "value": {
            "type": "number",
            "description": "The filter value used in comparison against match candidates.",
            "format": "double"
          }
        }
      },
      "TagFilterStringFilter": {
        "type": "object",
        "properties": {
          "in_values": {
            "type": "array",
            "description": "Values the filter tests against when using IN or NOT_IN match type.",
            "items": {
              "type": "string"
            }
          },
          "match": {
            "type": "object",
            "description": "If EXACT, compared strings have the exact value of the filter value.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringFilterStringFilterMatchType"
              }
            ]
          },
          "value": {
            "type": "string",
            "description": "The value the filter compares to the target trace or span field."
          }
        }
      },
      "apiError": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message describing what went wrong."
          }
        }
      },
      "configv1PageParams": {
        "type": "object",
        "properties": {
          "max_size": {
            "type": "integer",
            "description": "Sets the preferred number of items to return per page. If set to `0`, the\nserver will use its default value. Regardless of the value specified, clients\nmust never assume how many items will be returned.",
            "format": "int64"
          },
          "token": {
            "type": "string",
            "description": "An opaque page token that identifies which page the client should request.\nAn empty value indicates the first page."
          }
        }
      },
      "configv1PageResult": {
        "type": "object",
        "properties": {
          "next_token": {
            "type": "string",
            "description": "An opaque page token that identifies the next page of items that the\nclient should request. An empty value indicates that there are no\nmore items to return."
          }
        }
      },
      "dataunstableAnalyzeAlertsRequest": {
        "type": "object",
        "properties": {
          "alert_filters": {
            "type": "array",
            "description": "Semantic filters to apply to alerts",
            "items": {
              "$ref": "#/components/schemas/AnalyzeAlertsRequestAlertFilter"
            }
          },
          "alert_filters_combine_mode": {
            "type": "object",
            "description": "How to combine multiple alert filters (AND vs OR)",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestAlertFiltersCombineMode"
              }
            ]
          },
          "time_filter": {
            "type": "object",
            "description": "Time range filter (required)",
            "allOf": [
              {
                "$ref": "#/components/schemas/AnalyzeAlertsRequestTimeFilter"
              }
            ]
          }
        },
        "description": "AnalyzeAlertsRequest is the request for the AnalyzeAlerts API.\nRetrieves alerts (aggregated by alert_id) within a given time range that match the provided filters."
      },
      "dataunstableAnalyzeAlertsResponse": {
        "type": "object",
        "properties": {
          "alerts": {
            "type": "array",
            "description": "List of alerts matching the filter criteria",
            "items": {
              "$ref": "#/components/schemas/AnalyzeAlertsResponseAlert"
            }
          }
        },
        "description": "AnalyzeAlertsResponse is the response for the AnalyzeAlerts API.\nReturns a list of alerts matching the request criteria."
      },
      "dataunstableAnalyzeAlertsResponseLabel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the label (e.g., \"team\", \"environment\")"
          },
          "value": {
            "type": "string",
            "description": "The value of the label (e.g., \"platform\", \"production\")"
          }
        },
        "description": "Label represents a key-value pair associated with a monitor.\nMonitor labels provide metadata about the monitor that generated the alert."
      },
      "dataunstableAutocompleteResponse": {
        "type": "object",
        "properties": {
          "suggestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableSuggestion"
            }
          }
        }
      },
      "dataunstableCancelLogQueryResponse": {
        "type": "object"
      },
      "dataunstableColumnMeta": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/dataunstableColumnMetaType"
          }
        }
      },
      "dataunstableColumnMetaType": {
        "type": "string",
        "enum": [
          "BOOLEAN",
          "FLOAT",
          "STRING"
        ]
      },
      "dataunstableCreateEventRequest": {
        "type": "object",
        "properties": {
          "event": {
            "type": "object",
            "description": "Event to create.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableEvent"
              }
            ]
          }
        }
      },
      "dataunstableCreateEventResponse": {
        "type": "object"
      },
      "dataunstableDeleteEventResponse": {
        "type": "object"
      },
      "dataunstableDiscoveredLogField": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Field name (label key)."
          },
          "top_values": {
            "type": "array",
            "description": "Top values for this field, ordered by frequency.\nValues are truncated to 100 bytes to keep response size manageable.",
            "items": {
              "$ref": "#/components/schemas/dataunstableDiscoveredLogFieldValue"
            }
          },
          "total_count": {
            "type": "string",
            "description": "Total occurrences of this field across all logs.",
            "format": "uint64"
          }
        }
      },
      "dataunstableDiscoveredLogFieldValue": {
        "type": "object",
        "properties": {
          "count": {
            "type": "string",
            "description": "Number of occurrences of this value.",
            "format": "uint64"
          },
          "value": {
            "type": "string",
            "description": "The field value (truncated to 100 bytes)."
          }
        }
      },
      "dataunstableEvent": {
        "type": "object",
        "properties": {
          "category": {
            "type": "string",
            "description": "The category the event belongs to. Must be one of these categories:\n`alerts`, `broadcasts`, `chronosphere`, `deploys`, `feature_flags`,\n`infrastructure`, `third_party`."
          },
          "happened_at": {
            "type": "string",
            "description": "The time the event occurred. Must be between 24 hours in the past or 24 hours\nin the future. Defaults to `now` if not specified.",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "description": "Unique identifier"
          },
          "json_payload": {
            "type": "string",
            "description": "A string representation of the original event JSON. Max length 100,000 characters. Only json_payload or\nraw_json_payload can be set."
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map of user-supplied key:value pairs associated with the event. Max 200 labels\nper event. Key max length, 200 characters. Value max length, 5,000\ncharacters."
          },
          "raw_json_payload": {
            "type": "object",
            "properties": {},
            "description": "The JSON payload if the original event was in JSON format. Formatted as JSON. Max length,\n100,000 characters. Input Only. Only json_payload or raw_json_payload may be set."
          },
          "source": {
            "type": "string",
            "description": "Identifies where the data originated, in cases where a change to the\ninstrumentation or integration is needed. Max length, 50 characters."
          },
          "title": {
            "type": "string",
            "description": "A short description of the event that occurred, such as an email subject.\nMax length, 100 characters."
          },
          "type": {
            "type": "string",
            "description": "The event type, used to group and differentiate events within a `category`\nor `source`."
          }
        }
      },
      "dataunstableEventBucket": {
        "type": "object",
        "properties": {
          "end_time": {
            "type": "string",
            "description": "The end time of the time range this bucket covers.",
            "format": "date-time"
          },
          "groups": {
            "type": "array",
            "description": "The grouped data in this bucket. Ordered alphabetically by group name.",
            "items": {
              "$ref": "#/components/schemas/EventBucketGroup"
            }
          },
          "start_time": {
            "type": "string",
            "description": "The start time of the time range this bucket covers.",
            "format": "date-time"
          }
        },
        "description": "A single histogram bucket."
      },
      "dataunstableEventDetails": {
        "type": "object",
        "properties": {
          "category": {
            "type": "string",
            "description": "The category the event belongs to."
          },
          "happened_at": {
            "type": "string",
            "description": "The time the event occurred.",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "description": "Unique identifier"
          }
        }
      },
      "dataunstableEventField": {
        "type": "string",
        "enum": [
          "CATEGORY_EVENT_FIELD",
          "TYPE_EVENT_FIELD",
          "SOURCE_EVENT_FIELD",
          "LABEL_NAME_EVENT_FIELD",
          "LABEL_VALUE_EVENT_FIELD",
          "LENS_SERVICE_EVENT_FIELD"
        ]
      },
      "dataunstableEventGrafanaAnnotation": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier."
          },
          "login": {
            "type": "string",
            "description": "The email of the user that created the event if available."
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The properties and labels of the event. Grafana expects these to be a list of string\nbut to make it easier for our plugin we return it as a map of string."
          },
          "text": {
            "type": "string",
            "description": "The title of the event."
          },
          "time": {
            "type": "string",
            "description": "The happened_at of the event.",
            "format": "date-time"
          },
          "time_end": {
            "type": "string",
            "description": "The happened_at of the event",
            "format": "date-time"
          }
        },
        "description": "EventGrafanaAnnotation represents Event as a grafana annotation."
      },
      "dataunstableEventHistogramWithDetails": {
        "type": "object",
        "properties": {
          "event": {
            "type": "object",
            "description": "An individual event",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableEventDetails"
              }
            ]
          },
          "event_bucket": {
            "type": "object",
            "description": "A histogram bucket of events",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableEventBucket"
              }
            ]
          }
        }
      },
      "dataunstableFieldConfiguration": {
        "type": "object",
        "properties": {
          "list_logs_field_order": {
            "type": "array",
            "description": "list_logs_field_order defines the order of priority fields in the expanded log view in logs explorer.",
            "items": {
              "$ref": "#/components/schemas/dataunstableFieldMeta"
            }
          }
        }
      },
      "dataunstableFieldMeta": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/dataunstableLogFieldType"
          }
        }
      },
      "dataunstableGetEventHistogramResponse": {
        "type": "object",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "List of histogram buckets ordered in ASC order by start_time.",
            "items": {
              "$ref": "#/components/schemas/dataunstableEventBucket"
            }
          },
          "total_events": {
            "type": "string",
            "description": "The total number of events with this filter and time range.",
            "format": "int64"
          }
        }
      },
      "dataunstableGetEventResponse": {
        "type": "object",
        "properties": {
          "event": {
            "$ref": "#/components/schemas/dataunstableEvent"
          }
        }
      },
      "dataunstableGetEventsForMonitorResponse": {
        "type": "object",
        "properties": {
          "event_histogram_with_details": {
            "type": "array",
            "description": "The buckets and individual events making up a time range",
            "items": {
              "$ref": "#/components/schemas/dataunstableEventHistogramWithDetails"
            }
          },
          "total_events": {
            "type": "string",
            "description": "The total number of events in the time range",
            "format": "int64"
          }
        }
      },
      "dataunstableGetInstantQueryResponse": {
        "type": "object",
        "properties": {
          "grouped_by": {
            "type": "array",
            "description": "The names of the labels by which the results are grouped by.",
            "items": {
              "type": "string"
            }
          },
          "groups": {
            "type": "array",
            "description": "The grouped data at this instant. Ordered alphabetically by group name.",
            "items": {
              "$ref": "#/components/schemas/dataunstableGroupByOutput"
            }
          },
          "limit_enforced": {
            "type": "boolean",
            "description": "This field indicates whether the result is truncated by the limit requested."
          }
        }
      },
      "dataunstableGetLogClusterExecutionsResponse": {
        "type": "object",
        "properties": {
          "page": {
            "type": "object",
            "description": "Pagination token.",
            "allOf": [
              {
                "$ref": "#/components/schemas/configv1PageResult"
              }
            ]
          },
          "summaries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GetLogClusterExecutionsResponseExecutionSummary"
            }
          }
        }
      },
      "dataunstableGetLogClusterUsageResponse": {
        "type": "object",
        "properties": {
          "cluster_id": {
            "type": "string",
            "format": "int64"
          },
          "executions": {
            "$ref": "#/components/schemas/dataunstableGetLogClusterUsageResponseExecutions"
          },
          "key": {
            "type": "string"
          },
          "log_query": {
            "type": "string"
          },
          "pattern": {
            "type": "string"
          },
          "recommendation": {
            "$ref": "#/components/schemas/GetLogClusterUsageResponseRecommendation"
          },
          "references": {
            "$ref": "#/components/schemas/GetLogClusterUsageResponseReferences"
          },
          "utility_score": {
            "type": "number",
            "format": "float"
          },
          "utility_score_previous": {
            "type": "number",
            "format": "float"
          },
          "volume_bytes": {
            "type": "string",
            "format": "uint64"
          },
          "volume_bytes_24h": {
            "type": "string",
            "format": "uint64"
          },
          "volume_bytes_24h_previous": {
            "type": "string",
            "format": "uint64"
          },
          "volume_bytes_buckets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GetLogClusterUsageResponseUsageBucket"
            }
          },
          "volume_bytes_previous": {
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "dataunstableGetLogClusterUsageResponseExecutions": {
        "type": "object",
        "properties": {
          "dashboards": {
            "type": "string",
            "format": "uint64"
          },
          "explorer": {
            "type": "string",
            "format": "uint64"
          },
          "unique_users": {
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "dataunstableGetLogDiscoveryResponse": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "description": "Discovered log fields with their top values, ordered by frequency.\nNote: The \"message\" field is excluded from discovery as it's not useful for context.",
            "items": {
              "$ref": "#/components/schemas/dataunstableDiscoveredLogField"
            }
          }
        }
      },
      "dataunstableGetLogHistogramResponse": {
        "type": "object",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "List of histogram buckets ordered in ASC order by start_time.",
            "items": {
              "$ref": "#/components/schemas/dataunstableLogBucket"
            }
          }
        }
      },
      "dataunstableGetLoggingUsageResponse": {
        "type": "object",
        "properties": {
          "clusters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableGetLoggingUsageResponseLogCluster"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/GetLoggingUsageResponseMetadata"
          },
          "page": {
            "$ref": "#/components/schemas/configv1PageResult"
          }
        }
      },
      "dataunstableGetLoggingUsageResponseLogCluster": {
        "type": "object",
        "properties": {
          "cluster_id": {
            "type": "string",
            "format": "int64"
          },
          "key": {
            "type": "string"
          },
          "last_updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "log_query": {
            "type": "string"
          },
          "pattern": {
            "type": "string"
          },
          "utility_score": {
            "type": "number",
            "format": "float"
          },
          "utility_score_previous": {
            "type": "number",
            "format": "float"
          },
          "volume_bytes": {
            "type": "string",
            "format": "uint64"
          },
          "volume_bytes_24h": {
            "type": "string",
            "format": "uint64"
          },
          "volume_bytes_24h_previous": {
            "type": "string",
            "format": "uint64"
          },
          "volume_bytes_previous": {
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "dataunstableGetRangeQueryResponse": {
        "type": "object",
        "properties": {
          "grid_data": {
            "$ref": "#/components/schemas/dataunstableLogQueryGridData"
          },
          "metadata": {
            "type": "object",
            "description": "The metadata of the query.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GetRangeQueryResponseRangeQueryMetadata"
              }
            ]
          },
          "time_series_data": {
            "$ref": "#/components/schemas/dataunstableLogQueryTimeSeriesData"
          }
        }
      },
      "dataunstableGetTenantConfigurationResponse": {
        "type": "object",
        "properties": {
          "data_retention_days": {
            "type": "integer",
            "description": "Number of days the tenant is configured to",
            "format": "int32"
          },
          "primary_keys": {
            "type": "array",
            "description": "Names of primary key fields configured for the tenant",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "dataunstableGroupByInput": {
        "type": "object",
        "properties": {
          "field_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "dataunstableGroupByOutput": {
        "type": "object",
        "properties": {
          "field_values": {
            "type": "array",
            "description": "The name of this group within the bucket. Set to the value of the group_by field.\nUnset if group_by is unset.",
            "items": {
              "type": "string"
            }
          },
          "value": {
            "type": "number",
            "description": "The value of the aggregation in this group within the bucket.",
            "format": "double"
          }
        },
        "description": "A single group of logs within a bucket."
      },
      "dataunstableListEventFieldValuesResponse": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "description": "Field values are ordered by frequency of occurrence and then alphabetical order is used\nas the tiebreaker.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "dataunstableListEventGrafanaAnnotationsResponse": {
        "type": "object",
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableEventGrafanaAnnotation"
            }
          },
          "page": {
            "$ref": "#/components/schemas/configv1PageResult"
          },
          "query": {
            "type": "string",
            "description": "Returns the query that was used to generate the request."
          }
        }
      },
      "dataunstableListEventsResponse": {
        "type": "object",
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableEvent"
            }
          },
          "page": {
            "$ref": "#/components/schemas/configv1PageResult"
          }
        }
      },
      "dataunstableListLogFieldNamesResponse": {
        "type": "object",
        "properties": {
          "suggestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableSuggestion"
            }
          }
        }
      },
      "dataunstableListLogFieldValuesResponse": {
        "type": "object",
        "properties": {
          "suggestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableSuggestion"
            }
          }
        }
      },
      "dataunstableListLogsRequestSortOrder": {
        "type": "string",
        "enum": [
          "ASC",
          "DESC"
        ]
      },
      "dataunstableListLogsResponse": {
        "type": "object",
        "properties": {
          "clusters": {
            "type": "array",
            "description": "Clusters for the listed logs.",
            "items": {
              "$ref": "#/components/schemas/dataunstableLogCluster"
            }
          },
          "field_config": {
            "$ref": "#/components/schemas/dataunstableFieldConfiguration"
          },
          "log_fields": {
            "type": "object",
            "description": "Log fields (names and values) extracted from the logs in this response. Used for populating the logs explorer sidebar.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableLogFields"
              }
            ]
          },
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableLog"
            }
          },
          "page": {
            "type": "object",
            "description": "If set, there are more results to return.",
            "allOf": [
              {
                "$ref": "#/components/schemas/configv1PageResult"
              }
            ]
          }
        }
      },
      "dataunstableLog": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Data contains all the data for the log."
          },
          "timestamp": {
            "type": "string",
            "description": "Timestamp recorded on the log message.",
            "format": "date-time"
          }
        }
      },
      "dataunstableLogBucket": {
        "type": "object",
        "properties": {
          "end_time": {
            "type": "string",
            "description": "The end time of the time range this bucket covers.",
            "format": "date-time"
          },
          "groups": {
            "type": "array",
            "description": "The grouped data in this bucket. Ordered alphabetically by group name.",
            "items": {
              "$ref": "#/components/schemas/dataunstableGroupByOutput"
            }
          },
          "start_time": {
            "type": "string",
            "description": "The start time of the time range this bucket covers.",
            "format": "date-time"
          }
        },
        "description": "A single histogram bucket."
      },
      "dataunstableLogCluster": {
        "type": "object",
        "properties": {
          "filter": {
            "type": "string",
            "description": "Filter expression that can be used to select logs matching the cluster."
          },
          "num_logs": {
            "type": "integer",
            "description": "Number of logs present in this cluster.",
            "format": "int64"
          },
          "pattern": {
            "type": "string",
            "description": "The pattern that represents this cluster."
          }
        }
      },
      "dataunstableLogClusterId": {
        "type": "object",
        "properties": {
          "cluster_id": {
            "type": "string",
            "format": "int64"
          },
          "key": {
            "type": "string"
          }
        }
      },
      "dataunstableLogField": {
        "type": "object",
        "properties": {
          "count": {
            "type": "string",
            "format": "uint64"
          },
          "field_type": {
            "$ref": "#/components/schemas/dataunstableLogFieldType"
          },
          "name": {
            "type": "string"
          },
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableLogFieldValue"
            }
          }
        }
      },
      "dataunstableLogFieldType": {
        "type": "string",
        "enum": [
          "PK",
          "META",
          "DERIVED",
          "REGULAR"
        ]
      },
      "dataunstableLogFieldValue": {
        "type": "object",
        "properties": {
          "count": {
            "type": "string",
            "format": "uint64"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "dataunstableLogFields": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableLogField"
            }
          },
          "sample_count": {
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "dataunstableLogFilter": {
        "type": "object",
        "properties": {
          "happened_after": {
            "type": "string",
            "description": "Only log messages with a timestamp after this time will be returned.",
            "format": "date-time"
          },
          "happened_before": {
            "type": "string",
            "description": "Only log messages with a timestamp before this time will be returned.",
            "format": "date-time"
          },
          "query": {
            "type": "string",
            "description": "Specifies the query to run to filter logs. Query defined using logql."
          }
        }
      },
      "dataunstableLogQueryGridData": {
        "type": "object",
        "properties": {
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableColumnMeta"
            }
          },
          "rows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableRow"
            }
          }
        }
      },
      "dataunstableLogQueryListData": {
        "type": "object",
        "properties": {
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableLog"
            }
          }
        }
      },
      "dataunstableLogQueryTimeSeriesData": {
        "type": "object",
        "properties": {
          "group_by_dimension_names": {
            "type": "array",
            "description": "The names of the dimensions by which the results are grouped by.",
            "items": {
              "type": "string"
            }
          },
          "series": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogQueryTimeSeriesDataLogQueryTimeSeries"
            }
          }
        }
      },
      "dataunstableLogWithIngestionMatch": {
        "type": "object",
        "properties": {
          "log": {
            "type": "object",
            "description": "The log data.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableLog"
              }
            ]
          },
          "matches_ingestion_filter": {
            "type": "boolean",
            "description": "Whether this log would match the filter at ingestion time."
          }
        }
      },
      "dataunstableMetricMetadata": {
        "type": "object",
        "properties": {
          "aggregation_rule_slug": {
            "type": "string",
            "description": "If this is an aggregated metric, the slug of the aggregation rule that created it."
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of what the metric measures."
          },
          "is_aggregated": {
            "type": "boolean",
            "description": "Whether this metric is an aggregated metric derived from other metrics."
          },
          "name": {
            "type": "string",
            "description": "The name of the metric."
          },
          "resolution": {
            "type": "string",
            "description": "The resolution of the metric (e.g., \"1m\", \"5s\")."
          },
          "type": {
            "type": "object",
            "description": "The type of the metric (counter, gauge, etc.).",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableMetricType"
              }
            ]
          }
        },
        "description": "MetricMetadata contains metadata information about a metric."
      },
      "dataunstableMetricType": {
        "type": "string",
        "description": "MetricType defines the canonical metric types supported by the platform.\n\n - CUMULATIVE_COUNTER: A Prom-style cumulative counter, which stores a strictly increasing count\nof distinct events (but may reset to zero). Each datapoint stores the\nrunning total at the given timestamp.\n - GAUGE: A true gauge, which stores an observation of state at a point in time,\nwhere it is impossible to have two different states at a single point in\ntime. Each datapoint stores the value at the given timestamp.\n - DELTA_COUNTER: A delta counter, which stores the same type of data as COUNTER, but where\neach datapoint stores a strictly positive delta increment at the given\ntimestamp.\n - MEASUREMENT: A raw observation with some discrete value, e.g. individual request\nlatency, individual request size, etc. Unlike a counter, each MEASUREMENT\nevent has a discrete value. And unlike a gauge, there can be multiple\nvalues at any point in time.\n - CUMULATIVE_EXPONENTIAL_HISTOGRAM: An exponential histogram, where each datapoint is a structured value (not a\nfloat), which stores compressed buckets of cumulative measurement counts,\nalong with total sum and count.\n - DELTA_EXPONENTIAL_HISTOGRAM: An exponential histogram, where each datapoint is a structured value (not a\nfloat), which stores compressed buckets of measurement count deltas,\nalong with total sum and count.",
        "enum": [
          "CUMULATIVE_COUNTER",
          "GAUGE",
          "DELTA_COUNTER",
          "MEASUREMENT",
          "CUMULATIVE_EXPONENTIAL_HISTOGRAM",
          "DELTA_EXPONENTIAL_HISTOGRAM"
        ]
      },
      "dataunstablePassThroughQueryResponse": {
        "type": "object"
      },
      "dataunstablePollListLogFieldNamesResponse": {
        "type": "object",
        "properties": {
          "is_finished": {
            "type": "boolean"
          },
          "progress": {
            "type": "number",
            "format": "float"
          },
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          },
          "suggestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableSuggestion"
            }
          }
        }
      },
      "dataunstablePollListLogFieldValuesResponse": {
        "type": "object",
        "properties": {
          "is_finished": {
            "type": "boolean"
          },
          "progress": {
            "type": "number",
            "format": "float"
          },
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          },
          "suggestions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableSuggestion"
            }
          }
        }
      },
      "dataunstablePollListLogFieldsResponse": {
        "type": "object",
        "properties": {
          "is_finished": {
            "type": "boolean"
          },
          "log_fields": {
            "$ref": "#/components/schemas/dataunstableLogFields"
          },
          "progress": {
            "type": "number",
            "format": "float"
          },
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstablePollListLogsResponse": {
        "type": "object",
        "properties": {
          "clusters": {
            "type": "array",
            "description": "Clusters for the listed logs.",
            "items": {
              "$ref": "#/components/schemas/dataunstableLogCluster"
            }
          },
          "field_config": {
            "$ref": "#/components/schemas/dataunstableFieldConfiguration"
          },
          "is_finished": {
            "type": "boolean"
          },
          "log_fields": {
            "type": "object",
            "description": "Log fields (names and values) extracted from the logs in this response. Used for populating the logs explorer sidebar.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableLogFields"
              }
            ]
          },
          "logs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableLog"
            }
          },
          "page": {
            "type": "object",
            "description": "Pagination token.",
            "allOf": [
              {
                "$ref": "#/components/schemas/configv1PageResult"
              }
            ]
          },
          "progress": {
            "type": "number",
            "format": "float"
          },
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstablePollLogHistogramResponse": {
        "type": "object",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "List of histogram buckets ordered in ASC order by start_time.",
            "items": {
              "$ref": "#/components/schemas/dataunstableLogBucket"
            }
          },
          "is_finished": {
            "type": "boolean"
          },
          "progress": {
            "type": "number",
            "format": "float"
          },
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstablePollRangeQueryResponse": {
        "type": "object",
        "properties": {
          "grid_data": {
            "$ref": "#/components/schemas/dataunstableLogQueryGridData"
          },
          "is_finished": {
            "type": "boolean"
          },
          "list_data": {
            "$ref": "#/components/schemas/dataunstableLogQueryListData"
          },
          "metadata": {
            "type": "object",
            "description": "The metadata of the query.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GetRangeQueryResponseRangeQueryMetadata"
              }
            ]
          },
          "progress": {
            "type": "number",
            "format": "float"
          },
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          },
          "time_series_data": {
            "$ref": "#/components/schemas/dataunstableLogQueryTimeSeriesData"
          }
        }
      },
      "dataunstablePreviewLogsIngestionFilterRequestSortOrder": {
        "type": "string",
        "enum": [
          "ASC",
          "DESC"
        ]
      },
      "dataunstablePreviewLogsIngestionFilterResponse": {
        "type": "object",
        "properties": {
          "logs": {
            "type": "array",
            "description": "All logs returned from the query with ingestion filter match indicators.",
            "items": {
              "$ref": "#/components/schemas/dataunstableLogWithIngestionMatch"
            }
          }
        }
      },
      "dataunstableRangeQueryPageParams": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Opaque page token identifying which page to request. An empty token\nidentifies the first page."
          }
        }
      },
      "dataunstableRangeQueryPageResult": {
        "type": "object",
        "properties": {
          "next_token": {
            "type": "string",
            "description": "Opaque page token which identifies the next page of items which the\nclient should request. An empty next_token indicates that there are no\nmore items to return."
          }
        }
      },
      "dataunstableReadMetricMetadataResponse": {
        "type": "object",
        "properties": {
          "metadata": {
            "type": "object",
            "description": "The metadata for the requested metric.",
            "allOf": [
              {
                "$ref": "#/components/schemas/dataunstableMetricMetadata"
              }
            ]
          }
        },
        "description": "ReadMetricMetadataResponse contains the metadata for the requested metric."
      },
      "dataunstableRow": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/dataunstableValue"
            }
          }
        }
      },
      "dataunstableStartListLogFieldNamesResponse": {
        "type": "object",
        "properties": {
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstableStartListLogFieldValuesResponse": {
        "type": "object",
        "properties": {
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstableStartListLogFieldsResponse": {
        "type": "object",
        "properties": {
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstableStartListLogsResponse": {
        "type": "object",
        "properties": {
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstableStartLogHistogramResponse": {
        "type": "object",
        "properties": {
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstableStartRangeQueryResponse": {
        "type": "object",
        "properties": {
          "query_id": {
            "type": "string"
          },
          "refresh_interval_ms": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "dataunstableSuggestion": {
        "type": "object",
        "properties": {
          "count": {
            "type": "integer",
            "description": "The number of times this suggested value is seen in the query result.\nThe value could be approximate and not complete.",
            "format": "int64"
          },
          "type": {
            "$ref": "#/components/schemas/dataunstableSuggestionType"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "dataunstableSuggestionType": {
        "type": "string",
        "enum": [
          "FIELD_NAME",
          "FIELD_VALUE",
          "FILTER"
        ]
      },
      "dataunstableTimestampFilter": {
        "type": "object",
        "properties": {
          "happened_after": {
            "type": "string",
            "description": "Only log messages with a timestamp after this time will be returned.",
            "format": "date-time"
          },
          "happened_before": {
            "type": "string",
            "description": "Only log messages with a timestamp before this time will be returned.",
            "format": "date-time"
          }
        }
      },
      "dataunstableValue": {
        "type": "object",
        "properties": {
          "bool_value": {
            "type": "boolean"
          },
          "float_value": {
            "type": "number",
            "format": "double"
          },
          "string_value": {
            "type": "string"
          }
        }
      },
      "datav1ListTracesRequest": {
        "type": "object",
        "properties": {
          "end_time": {
            "type": "string",
            "description": "End time for the search.",
            "format": "date-time"
          },
          "operation": {
            "type": "string",
            "description": "Operation to filter on. An empty value doesn't apply any operation filter."
          },
          "query_type": {
            "type": "object",
            "description": "Type of query to perform.\nTRACE_IDS: Search for specific trace IDs.\nSERVICE_OPERATION: Search for traces with a specific service and operation, over a specific time frame.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ListTracesRequestQueryType"
              }
            ]
          },
          "service": {
            "type": "string",
            "description": "Service to filter on. An empty value doesn't apply any service filter."
          },
          "start_time": {
            "type": "string",
            "description": "Start time for the search.",
            "format": "date-time"
          },
          "tag_filters": {
            "type": "array",
            "description": "Tag filter to apply. An empty value doesn't apply any tag filter.",
            "items": {
              "$ref": "#/components/schemas/ListTracesRequestTagFilter"
            }
          },
          "trace_ids": {
            "type": "array",
            "description": "Trace IDs to search for.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "datav1ListTracesResponse": {
        "type": "object",
        "properties": {
          "traces": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1TracesData"
            }
          }
        }
      },
      "genericError": {
        "type": "object",
        "additionalProperties": true
      },
      "googlerpcStatus": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/protobufAny"
            }
          },
          "message": {
            "type": "string"
          }
        }
      },
      "protobufAny": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string"
          }
        },
        "additionalProperties": {
          "type": "object"
        }
      },
      "protobufNullValue": {
        "type": "string",
        "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`."
      },
      "resourcev1Resource": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "array",
            "description": "Set of attributes that describe the resource.\nAttribute keys MUST be unique (it is not allowed to have more than one\nattribute with the same key).",
            "items": {
              "$ref": "#/components/schemas/v1KeyValue"
            }
          },
          "dropped_attributes_count": {
            "type": "integer",
            "description": "dropped_attributes_count is the number of dropped attributes. If the value is 0, then\nno attributes were dropped.",
            "format": "int64"
          },
          "entity_refs": {
            "type": "array",
            "description": "Set of entities that participate in this Resource.\n\nNote: keys in the references MUST exist in attributes of this message.\n\nStatus: [Development]",
            "items": {
              "$ref": "#/components/schemas/v1EntityRef"
            }
          }
        },
        "description": "Resource information."
      },
      "tracev1Status": {
        "type": "object",
        "properties": {
          "code": {
            "type": "object",
            "description": "The status code.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StatusStatusCode"
              }
            ]
          },
          "message": {
            "type": "string",
            "description": "A developer-facing human readable error message."
          }
        },
        "description": "The Status type defines a logical error model that is suitable for different\nprogramming environments, including REST APIs and RPC APIs."
      },
      "v1AnyValue": {
        "type": "object",
        "properties": {
          "array_value": {
            "$ref": "#/components/schemas/v1ArrayValue"
          },
          "bool_value": {
            "type": "boolean"
          },
          "bytes_value": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "double_value": {
            "type": "number",
            "format": "double"
          },
          "int_value": {
            "type": "string",
            "format": "int64"
          },
          "kvlist_value": {
            "$ref": "#/components/schemas/v1KeyValueList"
          },
          "string_value": {
            "type": "string"
          }
        },
        "description": "AnyValue is used to represent any type of attribute value. AnyValue may contain a\nprimitive value such as a string or integer or it may contain an arbitrary nested\nobject containing arrays, key-value lists and primitives."
      },
      "v1ArrayValue": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "description": "Array of values. The array may be empty (contain 0 elements).",
            "items": {
              "$ref": "#/components/schemas/v1AnyValue"
            }
          }
        },
        "description": "ArrayValue is a list of AnyValue messages. We need ArrayValue as a message\nsince oneof in AnyValue does not allow repeated fields."
      },
      "v1EntityRef": {
        "type": "object",
        "properties": {
          "description_keys": {
            "type": "array",
            "description": "Descriptive (non-identifying) attribute keys of the entity.\nMAY change over the lifetime of the entity. MAY be empty.\nThese attribute keys are not part of entity's identity.\nThese keys MUST exist in the containing {message}.attributes.",
            "items": {
              "type": "string"
            }
          },
          "id_keys": {
            "type": "array",
            "description": "Attribute Keys that identify the entity.\nMUST not change during the lifetime of the entity. The Id must contain at least one attribute.\nThese keys MUST exist in the containing {message}.attributes.",
            "items": {
              "type": "string"
            }
          },
          "schema_url": {
            "title": "The Schema URL, if known. This is the identifier of the Schema that the entity data\nis recorded in. To learn more about Schema URL see\nhttps://opentelemetry.io/docs/specs/otel/schemas/#schema-url",
            "type": "string",
            "description": "This schema_url applies to the data in this message and to the Resource attributes\nreferenced by id_keys and description_keys.\nTODO: discuss if we are happy with this somewhat complicated definition of what\nthe schema_url applies to.\n\nThis field obsoletes the schema_url field in ResourceMetrics/ResourceSpans/ResourceLogs."
          },
          "type": {
            "type": "string",
            "description": "Defines the type of the entity. MUST not change during the lifetime of the entity.\nFor example: \"service\" or \"host\". This field is required and MUST not be empty\nfor valid entities."
          }
        },
        "description": "A reference to an Entity.\nEntity represents an object of interest associated with produced telemetry: e.g spans, metrics, profiles, or logs.\n\nStatus: [Development]"
      },
      "v1InstrumentationScope": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "array",
            "description": "Additional attributes that describe the scope. [Optional].\nAttribute keys MUST be unique (it is not allowed to have more than one\nattribute with the same key).",
            "items": {
              "$ref": "#/components/schemas/v1KeyValue"
            }
          },
          "dropped_attributes_count": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string",
            "description": "An empty instrumentation scope name means the name is unknown."
          },
          "version": {
            "type": "string"
          }
        },
        "description": "InstrumentationScope is a message representing the instrumentation scope information\nsuch as the fully qualified name and version."
      },
      "v1KeyValue": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/v1AnyValue"
          }
        },
        "description": "KeyValue is a key-value pair that is used to store Span attributes, Link\nattributes, etc."
      },
      "v1KeyValueList": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "description": "A collection of key/value pairs of key-value pairs. The list may be empty (may\ncontain 0 elements).\nThe keys MUST be unique (it is not allowed to have more than one\nvalue with the same key).",
            "items": {
              "$ref": "#/components/schemas/v1KeyValue"
            }
          }
        },
        "description": "KeyValueList is a list of KeyValue messages. We need KeyValueList as a message\nsince `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need\na list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to\navoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches\nare semantically equivalent."
      },
      "v1ResourceSpans": {
        "type": "object",
        "properties": {
          "resource": {
            "type": "object",
            "description": "The resource for the spans in this message.\nIf this field is not set then no resource info is known.",
            "allOf": [
              {
                "$ref": "#/components/schemas/resourcev1Resource"
              }
            ]
          },
          "schema_url": {
            "type": "string",
            "description": "The Schema URL, if known. This is the identifier of the Schema that the resource data\nis recorded in. Notably, the last part of the URL path is the version number of the\nschema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see\nhttps://opentelemetry.io/docs/specs/otel/schemas/#schema-url\nThis schema_url applies to the data in the \"resource\" field. It does not apply\nto the data in the \"scope_spans\" field which have their own schema_url field."
          },
          "scope_spans": {
            "type": "array",
            "description": "A list of ScopeSpans that originate from a resource.",
            "items": {
              "$ref": "#/components/schemas/v1ScopeSpans"
            }
          }
        },
        "description": "A collection of ScopeSpans from a Resource."
      },
      "v1ScopeSpans": {
        "type": "object",
        "properties": {
          "schema_url": {
            "type": "string",
            "description": "The Schema URL, if known. This is the identifier of the Schema that the span data\nis recorded in. Notably, the last part of the URL path is the version number of the\nschema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see\nhttps://opentelemetry.io/docs/specs/otel/schemas/#schema-url\nThis schema_url applies to all spans and span events in the \"spans\" field."
          },
          "scope": {
            "type": "object",
            "description": "The instrumentation scope information for the spans in this message.\nSemantically when InstrumentationScope isn't set, it is equivalent with\nan empty instrumentation scope name (unknown).",
            "allOf": [
              {
                "$ref": "#/components/schemas/v1InstrumentationScope"
              }
            ]
          },
          "spans": {
            "type": "array",
            "description": "A list of Spans that originate from an instrumentation scope.",
            "items": {
              "$ref": "#/components/schemas/v1Span"
            }
          }
        },
        "description": "A collection of Spans produced by an InstrumentationScope."
      },
      "v1Span": {
        "type": "object",
        "properties": {
          "attributes": {
            "title": "attributes is a collection of key/value pairs. Note, global attributes\nlike server name can be set using the resource API. Examples of attributes:",
            "type": "array",
            "description": "\"/http/user_agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"\n    \"/http/server_latency\": 300\n    \"example.com/myattribute\": true\n    \"example.com/score\": 10.239\n\nThe OpenTelemetry API specification further restricts the allowed value types:\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute\nAttribute keys MUST be unique (it is not allowed to have more than one\nattribute with the same key).",
            "items": {
              "$ref": "#/components/schemas/v1KeyValue"
            }
          },
          "dropped_attributes_count": {
            "type": "integer",
            "description": "dropped_attributes_count is the number of attributes that were discarded. Attributes\ncan be discarded because their keys are too long or because there are too many\nattributes. If this value is 0, then no attributes were dropped.",
            "format": "int64"
          },
          "dropped_events_count": {
            "type": "integer",
            "description": "dropped_events_count is the number of dropped events. If the value is 0, then no\nevents were dropped.",
            "format": "int64"
          },
          "dropped_links_count": {
            "type": "integer",
            "description": "dropped_links_count is the number of dropped links after the maximum size was\nenforced. If this value is 0, then no links were dropped.",
            "format": "int64"
          },
          "end_time_unix_nano": {
            "type": "string",
            "description": "end_time_unix_nano is the end time of the span. On the client side, this is the time\nkept by the local machine where the span execution ends. On the server side, this\nis the time when the server application handler stops running.\nValue is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.\n\nThis field is semantically required and it is expected that end_time >= start_time.",
            "format": "uint64"
          },
          "events": {
            "type": "array",
            "description": "events is a collection of Event items.",
            "items": {
              "$ref": "#/components/schemas/v1SpanEvent"
            }
          },
          "flags": {
            "type": "integer",
            "description": "Flags, a bit field.\n\nBits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace\nContext specification. To read the 8-bit W3C trace flag, use\n`flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.\n\nSee https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.\n\nBits 8 and 9 represent the 3 states of whether a span's parent\nis remote. The states are (unknown, is not remote, is remote).\nTo read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.\nTo read whether the span is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.\n\nWhen creating span messages, if the message is logically forwarded from another source\nwith an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD\nbe copied as-is. If creating from a source that does not have an equivalent flags field\n(such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST\nbe set to zero.\nReaders MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.\n\n[Optional].",
            "format": "int64"
          },
          "kind": {
            "type": "object",
            "description": "Distinguishes between spans generated in a particular context. For example,\ntwo spans with the same name may be distinguished using `CLIENT` (caller)\nand `SERVER` (callee) to identify queueing latency associated with the span.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpanSpanKind"
              }
            ]
          },
          "links": {
            "type": "array",
            "description": "links is a collection of Links, which are references from this span to a span\nin the same or different trace.",
            "items": {
              "$ref": "#/components/schemas/SpanLink"
            }
          },
          "name": {
            "type": "string",
            "description": "A description of the span's operation.\n\nFor example, the name can be a qualified method name or a file name\nand a line number where the operation is called. A best practice is to use\nthe same display name at the same call point in an application.\nThis makes it easier to correlate spans in different traces.\n\nThis field is semantically required to be set to non-empty string.\nEmpty value is equivalent to an unknown span name.\n\nThis field is required."
          },
          "parent_span_id": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "The `span_id` of this span's parent span. If this is a root span, then this\nfield must be empty. The ID is an 8-byte array.",
            "format": "byte"
          },
          "span_id": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "A unique identifier for a span within a trace, assigned when the span\nis created. The ID is an 8-byte array. An ID with all zeroes OR of length\nother than 8 bytes is considered invalid (empty string in OTLP/JSON\nis zero-length and thus is also invalid).\n\nThis field is required.",
            "format": "byte"
          },
          "start_time_unix_nano": {
            "type": "string",
            "description": "start_time_unix_nano is the start time of the span. On the client side, this is the time\nkept by the local machine where the span execution starts. On the server side, this\nis the time when the server's application handler starts running.\nValue is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.\n\nThis field is semantically required and it is expected that end_time >= start_time.",
            "format": "uint64"
          },
          "status": {
            "type": "object",
            "description": "An optional final status for this span. Semantically when Status isn't set, it means\nspan's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).",
            "allOf": [
              {
                "$ref": "#/components/schemas/tracev1Status"
              }
            ]
          },
          "trace_id": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "A unique identifier for a trace. All spans from the same trace share\nthe same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR\nof length other than 16 bytes is considered invalid (empty string in OTLP/JSON\nis zero-length and thus is also invalid).\n\nThis field is required.",
            "format": "byte"
          },
          "trace_state": {
            "type": "string",
            "description": "trace_state conveys information about request position in multiple distributed tracing graphs.\nIt is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header\nSee also https://github.com/w3c/distributed-tracing for more details about this field."
          }
        },
        "description": "A Span represents a single operation performed by a single component of the system.\n\nThe next available field id is 17."
      },
      "v1SpanEvent": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "array",
            "description": "attributes is a collection of attribute key/value pairs on the event.\nAttribute keys MUST be unique (it is not allowed to have more than one\nattribute with the same key).",
            "items": {
              "$ref": "#/components/schemas/v1KeyValue"
            }
          },
          "dropped_attributes_count": {
            "type": "integer",
            "description": "dropped_attributes_count is the number of dropped attributes. If the value is 0,\nthen no attributes were dropped.",
            "format": "int64"
          },
          "name": {
            "type": "string",
            "description": "name of the event.\nThis field is semantically required to be set to non-empty string."
          },
          "time_unix_nano": {
            "type": "string",
            "description": "time_unix_nano is the time the event occurred.",
            "format": "uint64"
          }
        },
        "description": "Event is a time-stamped annotation of the span, consisting of user-supplied\ntext description and key-value pairs."
      },
      "v1TracesData": {
        "type": "object",
        "properties": {
          "resource_spans": {
            "type": "array",
            "description": "An array of ResourceSpans.\nFor data coming from a single resource this array will typically contain\none element. Intermediary nodes that receive data from multiple origins\ntypically batch the data before forwarding further and in that case this\narray will contain multiple elements.",
            "items": {
              "$ref": "#/components/schemas/v1ResourceSpans"
            }
          }
        },
        "description": "TracesData represents the traces data that can be stored in a persistent storage,\nOR can be embedded by other protocols that transfer OTLP traces data but do\nnot implement the OTLP protocol.\n\nThe main difference between this message and collector protocol is that\nin this message there will not be any \"control\" or \"metadata\" specific to\nOTLP protocol.\n\nWhen new fields are added into this message, the OTLP request MUST be updated\nas well."
      }
    },
    "securitySchemes": {
      "ApiKeyAuth": {
        "type": "apiKey",
        "description": "Chronosphere API token",
        "name": "API-Token",
        "in": "header"
      }
    }
  },
  "x-original-swagger-version": "2.0"
}